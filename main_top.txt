import datetime
import hashlib
import json
import os
import re
import requests
import uuid
import firebase_admin
from firebase_admin import firestore, auth as firebase_auth
import functions_framework
from google import genai
from google.genai import types
from google.cloud import texttospeech
from google.cloud import vision
from google_auth_oauthlib.flow import Flow
from google.oauth2.credentials import Credentials
from google.auth.transport.requests import Request, AuthorizedSession
import google.auth
from googleapiclient.discovery import build

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
from io import BytesIO
from zoneinfo import ZoneInfo

plt.switch_backend('Agg') # Ensure stability in serverless environments

# --- CONFIGURATION ---
GEMINI_API_KEY = os.getenv("GEMINI_API_KEY", "").strip()
GEMINI_MODEL = os.getenv("GEMINI_MODEL", "gemini-2.0-flash-001")

def _gemini_model_candidates():
    models = [
        GEMINI_MODEL,
        "gemini-2.5-flash",
        "gemini-2.5-flash-lite",
        "gemini-2.5-pro",
        "gemini-2.0-flash-001",
        "gemini-2.0-flash",
        "gemini-2.0-flash-lite-001",
        "gemini-2.0-flash-lite"
    ]
    # Preserve order, remove duplicates/empties
    seen = set()
    ordered = []
    for m in models:
        if m and m not in seen:
            ordered.append(m)
            seen.add(m)
    return ordered

def gemini_generate(contents, **kwargs):
    if not ai_client:
        raise RuntimeError("GEMINI_API_KEY is missing or invalid")
    last_error = None
    for model in _gemini_model_candidates():
        try:
            return ai_client.models.generate_content(
                model=model,
                contents=contents,
                **kwargs
            )
        except Exception as e:
            last_error = e
            print(f"GEMINI MODEL ERROR ({model}): {e}")
    if last_error:
        raise last_error
    raise RuntimeError("No Gemini models available")
WA_TOKEN = os.getenv("WA_TOKEN", "")
PHONE_NUMBER_ID = os.getenv("PHONE_NUMBER_ID", "")
VERIFY_TOKEN = os.getenv("VERIFY_TOKEN", "")
TTS_LANGUAGE = "he-IL"
TTS_VOICE_NAME = "he-IL-Wavenet-C"
GOOGLE_MAPS_API_KEY = os.getenv("GOOGLE_MAPS_API_KEY", "")
GOOGLE_OAUTH_CLIENT_ID = os.getenv("GOOGLE_OAUTH_CLIENT_ID", "")
GOOGLE_OAUTH_CLIENT_SECRET = os.getenv("GOOGLE_OAUTH_CLIENT_SECRET", "")
GOOGLE_OAUTH_REDIRECT_URI = os.getenv(
    "GOOGLE_OAUTH_REDIRECT_URI",
    "https://us-central1-sportruma.cloudfunctions.net/garmin-bot-v2/oauth2callback"
)
SITE_LINK_BASE = os.getenv("SITE_LINK_BASE", "https://sportruma.web.app")
SITE_LINK_TTL_HOURS = int(os.getenv("SITE_LINK_TTL_HOURS", "48"))
ELEVENLABS_API_KEY = os.getenv("ELEVENLABS_API_KEY", "")
ELEVENLABS_VOICE_ID = os.getenv("ELEVENLABS_VOICE_ID", "21m00Tcm4TlvDq8ikWAM") # Example ID
CALENDAR_SCOPES = [
    "https://www.googleapis.com/auth/calendar",
    "https://www.googleapis.com/auth/calendar.events",
    "https://www.googleapis.com/auth/calendar.readonly",
    "openid",
    "https://www.googleapis.com/auth/userinfo.profile",
    "https://www.googleapis.com/auth/userinfo.email"
]
WORKOUTS_CATALOG_PATH = os.path.join(os.path.dirname(__file__), "workouts.json")
WORKOUT_RECOMMENDATION_COUNT = 6
LOCAL_TZ = ZoneInfo("Asia/Jerusalem")
NERVES_LADDER_IMAGE_URL = os.getenv("NERVES_LADDER_IMAGE_URL", "")
USE_GEMINI_WORKOUT_SCRIPT = os.getenv("USE_GEMINI_WORKOUT_SCRIPT", "true").lower() == "true"
HC_PROJECT_ID = os.getenv("HC_PROJECT_ID", "")
HC_LOCATION = os.getenv("HC_LOCATION", "us-central1")
HC_DATASET = os.getenv("HC_DATASET", "")
HC_FHIR_STORE = os.getenv("HC_FHIR_STORE", "")

PCL5_QUESTIONS = [
    "××™×š ×”××¦×‘ ×¨×•×— ×©×œ×š ×”×™×•×? ğŸ˜Š",
    "××™×š ×¨××ª ×”×× ×¨×’×™×” ×©×œ×š? âš¡",
    "××™×š ×™×©× ×ª ×”×œ×™×œ×”? ğŸ˜´",
    "××™×š ××–×’ ×”××•×•×™×¨ ×”×¤× ×™××™ ×©×œ×š ×›×¨×’×¢? (×¡×•×¢×¨ â›ˆï¸ / ××¢×•×¨×¤×œ ğŸŒ«ï¸ / ×©×§×˜ â˜€ï¸)"
]

# Morning/evening should ask mood, energy, and internal weather
DAILY_CHECKIN_QUESTION_INDEXES = [0, 1, 3]

PCL5_OPTIONS = [
    {"id": "1", "title": "1 - ×’×¨×•×¢ / ×¡×•×¢×¨ ×××•×“ â›ˆï¸"},
    {"id": "2", "title": "2 - ×œ× ××©×”×• / ××¢×•×¨×¤×œ ğŸŒ«ï¸"},
    {"id": "3", "title": "3 - ×¡×‘×™×¨ / ×›×›×” ×›×›×” ğŸŒ¤ï¸"},
    {"id": "4", "title": "4 - ×˜×•×‘ / ×‘×”×™×¨ â˜€ï¸"},
    {"id": "5", "title": "5 - ××¦×•×™×Ÿ / ×©×§×˜ ×•×¨×’×•×¢ âœ¨"}
]

SLEEP_STATE_OPTIONS = [
    {"id": "alert", "title": "×“×¨×•×š/×” (×¢×•×¨×¨×•×ª ×™×ª×¨) âš¡"},
    {"id": "frozen", "title": "×§×¤×•×/×” (× ×™×ª×•×§) â„ï¸"},
    {"id": "tired", "title": "×¢×™×™×£/×” (×§×¨×™×¡×”) ğŸ’¤"}
]

# --- INIT ---
if not firebase_admin._apps:
    firebase_admin.initialize_app()
db = firestore.client()
ai_client = genai.Client(api_key=GEMINI_API_KEY) if GEMINI_API_KEY else None
tts_client = None
vision_client = None

# --- HELPERS ---
def _clean_id(user_id):
    if not user_id: return ""
    return str(user_id).replace("@g.us", "").replace("@s.whatsapp.net", "").strip()

def normalize_phone(value):
    if not value:
        return ""
    return re.sub(r"\D", "", str(value))

def _healthcare_enabled():
    return bool(HC_PROJECT_ID and HC_LOCATION and HC_DATASET and HC_FHIR_STORE)

def _fhir_store_path():
    return (
        f"projects/{HC_PROJECT_ID}/locations/{HC_LOCATION}"
        f"/datasets/{HC_DATASET}/fhirStores/{HC_FHIR_STORE}"
    )

def _authorized_healthcare_session():
    creds, _ = google.auth.default(scopes=["https://www.googleapis.com/auth/cloud-platform"])
    return AuthorizedSession(creds)

def _fhir_base_url():
    return f"https://healthcare.googleapis.com/v1/{_fhir_store_path()}/fhir"

def _fhir_id_from_parts(*parts):
    raw = "-".join([str(p) for p in parts if p])
    safe = re.sub(r"[^A-Za-z0-9\-.]", "-", raw)
    if len(safe) > 64:
        digest = hashlib.sha1(raw.encode("utf-8")).hexdigest()
        safe = f"{safe[:40]}-{digest[:20]}"
    return safe[:64] if safe else hashlib.sha1(raw.encode("utf-8")).hexdigest()[:32]

def _fhir_gender(value):
    v = (value or "").lower()
    if v in ("female", "f"):
        return "female"
    if v in ("male", "m"):
        return "male"
    return "unknown"

def analyze_voice_tone(audio_bytes):
    if not audio_bytes:
        return None
    prompt = (
        "Analyze the tone, pitch, and speed of this voice message. "
        "Categorize it into one of these three nervous system states: "
        "1. 'fight_flight' (fast pace, high intensity, strong volume) "
        "2. 'freeze' (monotone, pauses, flat affect) "
        "3. 'collapse' (very weak voice, low energy, almost whispering) "
        "Return ONLY the category name: fight_flight, freeze, or collapse."
    )
    try:
        response = gemini_generate([
            types.Part.from_bytes(data=audio_bytes, mime_type="audio/ogg"),
            prompt
        ])
        res = (response.text or "").strip().lower()
        if "fight_flight" in res: return "fight_flight"
        if "freeze" in res: return "freeze"
        if "collapse" in res: return "collapse"
    except Exception as e:
        print(f"VOICE ANALYSIS ERROR: {e}")
    return None

def get_last_fhir_state(user_id):
    if not _healthcare_enabled():
        return None
    patient_id = _fhir_id_from_parts("user", _clean_id(user_id))
    url = f"{_fhir_base_url()}/Observation"
    # Search for nervous system state observations
    params = {
        "patient": f"Patient/{patient_id}",
        "code": "https://sportruma.app/observation|nervous_system_state",
        "_sort": "-date",
        "_count": "1"
    }
    try:
        session = _authorized_healthcare_session()
        res = session.get(url, params=params, timeout=10)
        if res.status_code == 200:
            bundle = res.json()
            entries = bundle.get("entry", [])
            if entries:
                obs = entries[0].get("resource", {})
                for coding in obs.get("code", {}).get("coding", []):
                    if coding.get("system") == "https://sportruma.app/nervous-system-state":
                        return coding.get("code")
    except Exception as e:
        print(f"FHIR QUERY ERROR: {e}")
    return None

def _entry_effective_datetime(entry, fallback_date=None):
    candidates = [
        entry.get("date"),
        entry.get("date_local"),
        entry.get("dateLocal"),
        entry.get("start_date_local"),
        entry.get("start_date")
    ]
    for c in candidates:
        if isinstance(c, str) and c:
            if "T" in c:
                return c
            return f"{c}T00:00:00Z"
    if isinstance(fallback_date, str) and re.match(r"^\d{4}-\d{2}-\d{2}$", fallback_date):
        return f"{fallback_date}T00:00:00Z"
    return datetime.datetime.utcnow().replace(microsecond=0).isoformat() + "Z"

def _add_component(components, code, display, value, unit=None, system=None):
    if value is None:
        return
    comp = {
        "code": {
            "coding": [{
                "system": system or "https://sportruma.app/observation",
                "code": code,
                "display": display
            }]
        },
        "valueQuantity": {
            "value": value
        }
    }
    if unit:
        comp["valueQuantity"]["unit"] = unit
    components.append(comp)

def _build_patient_resource(user_id, user_doc):
    doc = user_doc or {}
    name = doc.get("name") or "User"
    phone = normalize_phone(user_id)
    telecom = []
    if phone:
        telecom.append({"system": "phone", "value": phone})
    if doc.get("email"):
        telecom.append({"system": "email", "value": doc.get("email")})
    return {
        "resourceType": "Patient",
        "id": _fhir_id_from_parts("user", _clean_id(user_id)),
        "identifier": [{
            "system": "https://sportruma.app/user-id",
            "value": str(user_id)
        }],
        "name": [{"text": name}],
        "gender": _fhir_gender(doc.get("gender")),
        "telecom": telecom
    }

def _build_observation_resource(user_id, entry_id, entry, patient_id):
    components = []
    hrv = entry.get("hrv_consistent")
    rhr = entry.get("restingHR") or entry.get("resting_hr")
    stress = entry.get("stressScore")
    sleep_secs = entry.get("sleepSecs")
    workout_minutes = entry.get("workout_minutes")
    workout_distance_km = entry.get("workout_distance_km")
    workout_count = entry.get("workout_count")
    mood = entry.get("survey_0")
    energy = entry.get("survey_1")
    weather = entry.get("survey_3")

    _add_component(components, "hrv", "Heart rate variability", hrv, unit="ms")
    _add_component(components, "resting_hr", "Resting heart rate", rhr, unit="beats/min")
    _add_component(components, "stress_score", "Stress score", stress)
    _add_component(
        components,
        "sleep_hours",
        "Sleep duration",
        round((sleep_secs or 0) / 3600, 2) if sleep_secs else None,
        unit="h"
    )
    _add_component(components, "workout_minutes", "Workout minutes", workout_minutes, unit="min")
    _add_component(components, "workout_distance_km", "Workout distance", workout_distance_km, unit="km")
    _add_component(components, "workout_count", "Workout count", workout_count)
    _add_component(components, "survey_mood", "Mood score", mood)
    _add_component(components, "survey_energy", "Energy score", energy)
    _add_component(components, "survey_weather", "Internal weather score", weather)

    if not components:
        return None

    observation_id = _fhir_id_from_parts("obs", patient_id, entry_id)
    return {
        "resourceType": "Observation",
        "id": observation_id,
        "status": "final",
        "category": [{
            "coding": [{
                "system": "http://terminology.hl7.org/CodeSystem/observation-category",
                "code": "vital-signs",
                "display": "Vital Signs"
            }]
        }],
        "code": {
            "coding": [{
                "system": "https://sportruma.app/observation",
                "code": "wellness_summary",
                "display": "Wellness summary"
            }]
        },
        "subject": {"reference": f"Patient/{patient_id}"},
        "effectiveDateTime": _entry_effective_datetime(entry, fallback_date=str(entry_id)),
        "component": components
    }

def _upsert_fhir_resource(resource_type, resource_id, body):
    url = f"{_fhir_base_url()}/{resource_type}/{resource_id}"
    session = _authorized_healthcare_session()
    res = session.put(url, json=body, timeout=15)
    if res.status_code in (200, 201):
        return True, res.json()
    print(f"FHIR UPSERT ERROR {resource_type}: {res.status_code} {res.text}")
    return False, None

def export_user_to_healthcare(user_id, days=14, force=False):
    if not _healthcare_enabled():
        return {"ok": False, "error": "Missing HC_* configuration"}
    user_doc = get_user_doc(user_id)
    if not user_doc:
        return {"ok": False, "error": "User not found"}

    patient = _build_patient_resource(user_id, user_doc)
    patient_id = patient["id"]
    ok, _ = _upsert_fhir_resource("Patient", patient_id, patient)
    if not ok:
        return {"ok": False, "error": "Failed to upsert patient"}

    doc_id = _clean_id(user_id)
    history_docs = db.collection("users").document(doc_id).collection("wellness_history") \
        .order_by("id", direction=firestore.Query.DESCENDING).limit(days).get()

    exported = 0
    skipped = 0
    errors = 0

    for d in history_docs:
        entry = d.to_dict() or {}
        if not force and entry.get("healthcare_exported_at"):
            skipped += 1
            continue

        observation = _build_observation_resource(user_id, d.id, entry, patient_id)
        if not observation:
            skipped += 1
            continue

        obs_id = observation["id"]
        ok, _ = _upsert_fhir_resource("Observation", obs_id, observation)
        if ok:
            d.reference.set({
                "healthcare_exported_at": firestore.SERVER_TIMESTAMP,
                "healthcare_observation_id": obs_id
            }, merge=True)
            exported += 1
        else:
            errors += 1

    return {
        "ok": errors == 0,
        "exported": exported,
        "skipped": skipped,
        "errors": errors,
        "patient_id": patient_id
    }

def t_by_gender(user_doc, male_text, female_text):
    gender = (user_doc or {}).get("gender", "male")
    return female_text if gender == "female" else male_text

def is_group(chat_id):
    return "@g.us" in str(chat_id) or "-" in str(chat_id)

def _first_word(s):
    if not s: return ""
    parts = str(s).strip().split()
    if not parts: return ""
    word = parts[0]
    # If it's just digits, add 'i' prefix for Intervals.icu athlete ID
    if word.isdigit():
        return f"i{word}"
    return word

def download_wa_media(media_id):
    """××•×¨×™×“ ×§×•×‘×¥ ××“×™×” (××•×“×™×•) ××•×•××˜×¡××¤ ×•××—×–×™×¨ ××ª ×”×‘×™×˜×™× ×©×œ×•."""
    headers = {"Authorization": f"Bearer {WA_TOKEN}"}
    try:
        # 1. ×§×‘×œ×ª URL ×œ×”×•×¨×“×”
        res = requests.get(f"https://graph.facebook.com/v21.0/{media_id}", headers=headers, timeout=10)
        if res.status_code != 200: return None
        download_url = res.json().get("url")
        
        # 2. ×”×•×¨×“×ª ×”×§×•×‘×¥ ×‘×¤×•×¢×œ
        res = requests.get(download_url, headers=headers, timeout=15)
        if res.status_code == 200:
            return res.content
    except Exception as e:
        print(f"Error downloading media: {e}")
    return None

def send_wa(to, body, interactive_list=None):
    to_clean = _clean_id(to)
    headers = {"Authorization": f"Bearer {WA_TOKEN}"}
    url = f"https://graph.facebook.com/v21.0/{PHONE_NUMBER_ID}/messages"
    
    if interactive_list:
        payload = {
            "messaging_product": "whatsapp",
            "to": to_clean,
            "type": "interactive",
            "interactive": interactive_list
        }
    else:
        payload = {
            "messaging_product": "whatsapp",
            "to": to_clean,
            "type": "text",
            "text": {"body": str(body) if body else "..."}
        }
        
    print(f"SENDING WA to {to_clean}...")
    try:
        res = requests.post(url, json=payload, headers=headers, timeout=10)
        print(f"WA STATUS: {res.status_code}")
        if res.status_code != 200:
            print(f"WA ERROR DETAIL: {res.text}")
            # Fallback for interactive lists that might fail
            if res.status_code == 400 and interactive_list:
                print("Interactive list failed, falling back to simple text...")
                fallback_payload = {
                    "messaging_product": "whatsapp",
                    "to": to_clean,
                    "type": "text",
                    "text": {"body": str(body)}
                }
                res2 = requests.post(url, json=fallback_payload, headers=headers, timeout=10)
                print(f"Fallback WA STATUS: {res2.status_code}")
    except Exception as e:
        print(f"Error sending WA: {e}")

def send_wa_poll(to, question, options, prefix="poll_ans_"):
    """Sends a poll-like interactive list message (Cloud API stable version)."""
    to_clean = _clean_id(to)
    
    # Map options to the interactive list format
    rows = []
    for opt in options:
        rows.append({
            "id": f"{prefix}{opt['id']}",
            "title": opt['title'], # Fixed: used 'title' instead of 'label'
            "description": "×œ×—×¥ ×œ×‘×—×™×¨×”"
        })
        
    interactive_list = {
        "type": "list",
        "header": {"type": "text", "text": "×¨×’×¢ ×©×œ ×›× ×•×ª âœ¨"},
        "body": {"text": question[:1024]},
        "footer": {"text": "×‘×—×¨/×™ ××ª ×”×ª×©×•×‘×” ×”××ª××™××” ×‘×™×•×ª×¨"},
        "action": {
            "button": "×‘×—×¨ ×ª×©×•×‘×”",
            "sections": [
                {
                    "title": "××¤×©×¨×•×™×•×ª",
                    "rows": rows
                }
            ]
        }
    }
    
    send_wa(to_clean, question, interactive_list=interactive_list)

def send_wa_location(to, lat, lon, name="", address=""):
    """×©×•×œ×—×ª ×”×•×“×¢×ª ××™×§×•× ×œ××©×ª××©."""
    to_clean = _clean_id(to)
    headers = {"Authorization": f"Bearer {WA_TOKEN}"}
    payload = {
        "messaging_product": "whatsapp",
        "to": to_clean,
        "type": "location",
        "location": {
            "longitude": lon,
            "latitude": lat,
            "name": name,
            "address": address
        }
    }
    try:
        res = requests.post(
            f"https://graph.facebook.com/v21.0/{PHONE_NUMBER_ID}/messages",
            json=payload,
            headers=headers,
            timeout=10
        )
        print(f"Send location status: {res.status_code}")
    except Exception as e:
        print(f"Error sending location: {e}")

def send_wa_audio(to, media_id):
    """×©×•×œ×—×ª ×”×•×“×¢×ª ×§×•×œ ×œ××©×ª××©."""
    to_clean = _clean_id(to)
    headers = {"Authorization": f"Bearer {WA_TOKEN}"}
    payload = {
        "messaging_product": "whatsapp",
        "to": to_clean,
        "type": "audio",
        "audio": {"id": media_id}
    }
    try:
        res = requests.post(
            f"https://graph.facebook.com/v21.0/{PHONE_NUMBER_ID}/messages",
            json=payload,
            headers=headers,
            timeout=10
        )
        print(f"Send audio status: {res.status_code}")
    except Exception as e:
        print(f"Error sending audio: {e}")

def normalize_email(email):
    return (email or "").strip().lower()

def _viewer_doc_id(email):
    if not email:
        return ""
    safe = re.sub(r"[^a-z0-9]+", "_", email.lower())
    safe = safe.strip("_")
    return safe or uuid.uuid4().hex

def _share_owner_ref(owner_phone):
    return db.collection("user_shares").document(_clean_id(owner_phone))

def list_viewers_for_owner(owner_phone):
    if not owner_phone:
        return []
    viewers = []
    try:
        snapshot = _share_owner_ref(owner_phone).collection("viewers").get()
        for doc in snapshot:
            data = doc.to_dict() or {}
            email = normalize_email(data.get("email"))
            if email:
                viewers.append({
                    "email": email,
                    "added_at": data.get("added_at")
                })
    except Exception as e:
        print(f"SHARE LIST VIEWERS ERROR: {e}")
    viewers.sort(key=lambda v: v.get("email") or "")
    return viewers

def has_view_access(viewer_email, owner_phone):
    if not viewer_email or not owner_phone:
        return False
    try:
        doc = _share_owner_ref(owner_phone).collection("viewers").document(_viewer_doc_id(viewer_email)).get()
        return doc.exists
    except Exception as e:
        print(f"SHARE CHECK ERROR: {e}")
        return False

def list_shared_owners_for_email(viewer_email):
    if not viewer_email:
        return []
    owners = []
    try:
        matches = db.collection_group("viewers").where("email", "==", viewer_email).get()
        seen = set()
        for doc in matches:
            parent = doc.reference.parent.parent
            if not parent:
                continue
            owner_phone = parent.id
            if owner_phone in seen:
                continue
            seen.add(owner_phone)
            u_doc = get_user_doc(owner_phone)
            owners.append({
                "phone": owner_phone,
                "name": (u_doc or {}).get("name") or ""
            })
    except Exception as e:
        print(f"SHARED OWNERS LOOKUP ERROR: {e}")
    return owners

def strip_emojis(text):
    if not text:
        return ""
    # Remove common emoji ranges + variation selectors
    cleaned = re.sub(
        r"[\U0001F300-\U0001FAFF\U00002700-\U000027BF\U000024C2-\U0001F251]+",
        " ",
        text,
        flags=re.UNICODE
    )
    cleaned = cleaned.replace("\uFE0F", " ")
    cleaned = re.sub(r"\s+", " ", cleaned).strip()
    return cleaned

def is_simple_greeting(text):
    t = (text or "").strip().lower()
    if not t:
        return False
    t = re.sub(r"[^\w\u0590-\u05FF]+", "", t)
    greetings = {"×”×™×™", "×”×™", "×©×œ×•×", "××”×œ×Ÿ", "×”×œ×•", "hello", "hi", "hey"}
    return t in greetings

def get_linked_phone(uid, email):
    if uid:
        try:
            doc = db.collection("auth_links").document(uid).get()
            if doc.exists:
                return normalize_phone((doc.to_dict() or {}).get("phone"))
        except Exception as e:
            print(f"AUTH LINK UID LOOKUP ERROR: {e}")
    email_norm = normalize_email(email)
    if email_norm:
        try:
            matches = db.collection("auth_links").where("email", "==", email_norm).limit(1).get()
            for doc in matches:
                return normalize_phone((doc.to_dict() or {}).get("phone"))
        except Exception as e:
            print(f"AUTH LINK EMAIL LOOKUP ERROR: {e}")
    return None

def create_site_link_token(phone):
    token = uuid.uuid4().hex
    db.collection("site_link_tokens").document(token).set({
        "phone": normalize_phone(phone),
        "created_at": firestore.SERVER_TIMESTAMP,
        "used_at": None
    })
    return token

def build_site_link(phone):
    token = create_site_link_token(phone)
    return f"{SITE_LINK_BASE}/?link_token={token}"

def is_link_token_expired(created_at):
    if not created_at:
        return True
    now = datetime.datetime.utcnow()
    try:
        return created_at < (now - datetime.timedelta(hours=SITE_LINK_TTL_HOURS))
    except Exception:
        return False

def verify_site_user(request):
    auth_header = request.headers.get("Authorization", "")
    if not auth_header.startswith("Bearer "):
        return None, "Missing Authorization header"
    token = auth_header.split(" ", 1)[1].strip()
    if not token:
        return None, "Missing token"
    try:
        decoded = firebase_auth.verify_id_token(token)
    except Exception as e:
        print(f"SITE AUTH ERROR: {e}")
        return None, "Invalid token"
    uid = decoded.get("uid") or decoded.get("sub")
    email = normalize_email(decoded.get("email"))
    phone = normalize_phone(decoded.get("phone_number"))
    if not phone:
        phone = get_linked_phone(uid, email)
    return {"uid": uid, "email": email, "phone": phone}, None

def json_response(payload, status=200):
    headers = {
        "Content-Type": "application/json",
        "Access-Control-Allow-Origin": "*",
        "Access-Control-Allow-Methods": "POST, GET, OPTIONS",
        "Access-Control-Allow-Headers": "Content-Type, Authorization"
    }
    return (json.dumps(payload, ensure_ascii=False), status, headers)

def upload_wa_media(file_bytes, file_name, mime_type):
    """××¢×œ×” ×§×•×‘×¥ ×œ×•×•×˜×¡××¤ ×•××—×–×™×¨ ××ª ×”-media_id."""
    headers = {"Authorization": f"Bearer {WA_TOKEN}"}
    files = {
        "file": (file_name, file_bytes, mime_type),
        "messaging_product": (None, "whatsapp")
    }
    try:
        res = requests.post(
            f"https://graph.facebook.com/v21.0/{PHONE_NUMBER_ID}/media",
            headers=headers,
            files=files,
            timeout=20
        )
        if res.status_code == 200:
            return res.json().get("id")
        print(f"Media upload failed: {res.text}")
    except Exception as e:
        print(f"Error uploading media: {e}")
    return None

def tts_generate_audio(text):
    """Generates Hebrew TTS audio bytes (OGG_OPUS) using Google Cloud TTS Neural2."""
    try:
        global tts_client
        if tts_client is None:
            tts_client = texttospeech.TextToSpeechClient()
        
        # Determine if it's SSML
        if text.strip().startswith("<speak>"):
            synthesis_input = texttospeech.SynthesisInput(ssml=text)
        else:
            # Wrap plain text in speak for consistency if needed, 
            # but SynthesisInput handles both.
            synthesis_input = texttospeech.SynthesisInput(text=text)
            
        voice = texttospeech.VoiceSelectionParams(
            language_code=TTS_LANGUAGE,
            name=TTS_VOICE_NAME
        )
        audio_config = texttospeech.AudioConfig(
            audio_encoding=texttospeech.AudioEncoding.OGG_OPUS,
            speaking_rate=0.92, # Slightly slower for clarity
            pitch=0.0
        )
        response = tts_client.synthesize_speech(
            input=synthesis_input,
            voice=voice,
            audio_config=audio_config
        )
        return response.audio_content
    except Exception as e:
        print(f"TTS ERROR: {e}")
        return None

def generate_elevenlabs_audio(text):
    """Generates Hebrew TTS audio bytes using ElevenLabs."""
    if not ELEVENLABS_API_KEY:
        print("ELEVENLABS API KEY MISSING")
        return None
    
    url = f"https://api.elevenlabs.io/v1/text-to-speech/{ELEVENLABS_VOICE_ID}"
    headers = {
        "Accept": "audio/mpeg",
        "Content-Type": "application/json",
        "xi-api-key": ELEVENLABS_API_KEY
    }
    # ElevenLabs supports some SSML-like tags depending on the model.
    # We can also just clean the SSML tags and use periods for pauses if needed.
    clean_text = re.sub(r"<[^>]+>", " ", text).strip()
    
    data = {
        "text": clean_text,
        "model_id": "eleven_multilingual_v2",
        "voice_settings": {
            "stability": 0.5,
            "similarity_boost": 0.75
        }
    }
    try:
        res = requests.post(url, json=data, headers=headers, timeout=30)
        if res.status_code == 200:
            return res.content
        else:
            print(f"ELEVENLABS ERROR: {res.status_code} - {res.text}")
    except Exception as e:
        print(f"ELEVENLABS EXCEPTION: {e}")
    return None

def send_tts_reply(to, text, file_prefix="reply", use_elevenlabs=True, is_ssml=False):
    if not text:
        return
    
    audio_text = strip_emojis(str(text))
    if not audio_text:
        return
    # If the text is wrapped in <speak>, it's SSML
    if audio_text.strip().startswith("<speak>"):
        is_ssml = True
        
    if len(audio_text) > 3500:
        audio_text = audio_text[:3500] + "..."
    
    audio_bytes = None
    
    # For workout scripts (which have heavy SSML/breaks), Google Neural2 is often more reliable
    # because it follows the timing instructions perfectly.
    prefer_google = is_ssml and file_prefix == "workout"
    
    if use_elevenlabs and ELEVENLABS_API_KEY and not prefer_google:
        audio_bytes = generate_elevenlabs_audio(audio_text)
    
    if not audio_bytes:
        audio_bytes = tts_generate_audio(audio_text)
    
    if audio_bytes:
        # Use a more descriptive filename for workouts
        filename = f"{file_prefix}_{uuid.uuid4().hex[:8]}.ogg"
        media_id = upload_wa_media(audio_bytes, filename, "audio/ogg")
        if media_id:
            send_wa_audio(to, media_id)

def get_oauth_client_config():
    return {
        "web": {
            "client_id": GOOGLE_OAUTH_CLIENT_ID,
            "client_secret": GOOGLE_OAUTH_CLIENT_SECRET,
            "auth_uri": "https://accounts.google.com/o/oauth2/auth",
            "token_uri": "https://oauth2.googleapis.com/token",
            "redirect_uris": [GOOGLE_OAUTH_REDIRECT_URI]
        }
    }

def calendar_connect_url(user_id):
    base = GOOGLE_OAUTH_REDIRECT_URI.replace("/oauth2callback", "")
    return f"{base}/connect_calendar?state={user_id}"

def save_calendar_tokens(user_id, creds):
    token_data = {
        "access_token": creds.token,
        "refresh_token": creds.refresh_token,
        "token_uri": creds.token_uri,
        "client_id": creds.client_id,
        "client_secret": creds.client_secret,
        "scopes": list(creds.scopes or []),
        "expiry": creds.expiry.isoformat() if creds.expiry else None
    }
    db.collection("users").document(_clean_id(user_id)).set({
        "calendar_tokens": token_data
    }, merge=True)

def load_calendar_credentials(user_id):
    user_doc = get_user_doc(user_id)
    token_data = user_doc.get("calendar_tokens")
    if not token_data:
        return None
    
    # Use environment variables as fallback for client_id/secret if missing in token_data
    c_id = token_data.get("client_id") or GOOGLE_OAUTH_CLIENT_ID
    c_secret = token_data.get("client_secret") or GOOGLE_OAUTH_CLIENT_SECRET
    
    creds = Credentials(
        token=token_data.get("access_token"),
        refresh_token=token_data.get("refresh_token"),
        token_uri=token_data.get("token_uri") or "https://oauth2.googleapis.com/token",
        client_id=c_id,
        client_secret=c_secret,
        scopes=token_data.get("scopes") or CALENDAR_SCOPES
    )
    if token_data.get("expiry"):
        try:
            # Handle both ISO format and potential timestamp
            expiry = token_data["expiry"]
            if isinstance(expiry, (int, float)):
                creds.expiry = datetime.datetime.fromtimestamp(expiry)
            else:
                creds.expiry = datetime.datetime.fromisoformat(expiry)
        except Exception:
            pass
    return creds

def get_calendar_service(user_id):
    try:
        creds = load_calendar_credentials(user_id)
        if not creds:
            print(f"DEBUG: No calendar credentials for {user_id}")
            return None
            
        # Check if we need to refresh
        if creds.expired or (creds.expiry and creds.expiry <= datetime.datetime.utcnow() + datetime.timedelta(minutes=5)):
            if creds.refresh_token:
                print(f"DEBUG: Refreshing calendar token for {user_id}")
                try:
                    creds.refresh(Request())
                    save_calendar_tokens(user_id, creds)
                except Exception as e:
                    print(f"CALENDAR REFRESH ERROR for {user_id}: {e}")
                    # If refresh fails, it might be due to revoked access
                    return None
            else:
                print(f"DEBUG: Calendar token expired and no refresh token for {user_id}")
                return None
                
        return build("calendar", "v3", credentials=creds, cache_discovery=False)
    except Exception as e:
        print(f"GET CALENDAR SERVICE ERROR for {user_id}: {e}")
        return None

def fetch_upcoming_events(user_id, max_results=5):
    try:
        service = get_calendar_service(user_id)
        if not service:
            return None
        now = datetime.datetime.utcnow().isoformat() + "Z"
        events_result = service.events().list(
            calendarId="primary",
            timeMin=now,
            maxResults=max_results,
            singleEvents=True,
            orderBy="startTime"
        ).execute()
        return events_result.get("items", [])
    except Exception as e:
        print(f"FETCH UPCOMING EVENTS ERROR for {user_id}: {e}")
        return None

def get_event_display_title(evt):
    summary = evt.get("summary", "××™×¨×•×¢ ×œ×œ× ×›×•×ª×¨×ª")
    start_raw = evt.get("start", {}).get("dateTime") or evt.get("start", {}).get("date")
    
    emoji_map = {
        "××™××•×Ÿ": "ğŸ’ª",
        "×¨×™×¦×”": "ğŸƒ",
        "×™×•×’×”": "ğŸ§˜",
        "×©×™× ×”": "ğŸ˜´",
        "×—×‘×¨×™×": "ğŸ‘¥",
        "××©×¤×—×”": "ğŸ ",
        "×¢×‘×•×“×”": "ğŸ’¼",
        "×œ×™××•×“×™×": "ğŸ“š",
        "××˜×œ×•×ª": "ğŸ“",
        "×–××Ÿ": "ğŸ•’",
        "××•×›×œ": "ğŸ•",
        "×¤×’×™×©×”": "ğŸ¤",
        "×˜×™×¤×•×œ": "ğŸ§˜",
        "××¨×¤××”": "ğŸ¥",
        "×¡×™×“×•×¨×™×": "ğŸš²",
        "×“×™×™×˜": "â¤ï¸",
        "×× ×•×—×”": "ğŸ§˜"
    }
    
    # Determine emoji
    chosen_emoji = "ğŸ”¹"
    for key, emo in emoji_map.items():
        if key in summary:
            chosen_emoji = emo
            break

    try:
        if "T" in start_raw:
            dt = datetime.datetime.fromisoformat(start_raw.replace("Z", "+00:00"))
            dt_il = dt.astimezone(ZoneInfo("Israel"))
            display_start = dt_il.strftime("%H:%M (%d/%m)")
        else:
            dt = datetime.datetime.strptime(start_raw, "%Y-%m-%d")
            display_start = dt.strftime("%d/%m")
    except:
        display_start = start_raw
        
    return f"{chosen_emoji} {summary} â€” {display_start}"

def get_edit_event_menu(events):
    rows = []
    for evt in events:
        evt_id = evt.get("id")
        if not evt_id:
            continue
        title = get_event_display_title(evt)
        rows.append({
            "id": f"event_edit_{evt_id}",
            "title": title[:72],
            "description": "×œ×—×¥ ×œ×‘×—×™×¨×”"
        })
    if not rows:
        return None
    return {
        "type": "list",
        "header": {"type": "text", "text": "×‘×—×™×¨×ª ××™×¨×•×¢ ×œ×¢×¨×™×›×”"},
        "body": {"text": "×‘×—×¨/×™ ××ª ×”××™×¨×•×¢ ×©×‘×¨×¦×•× ×š ×œ×©× ×•×ª:"},
        "action": {
            "button": "×‘×—×¨ ××™×¨×•×¢",
            "sections": [{"title": "××™×¨×•×¢×™× ×§×¨×•×‘×™×", "rows": rows}]
        }
    }

def get_suggestions_menu(suggestions):
    rows = []
    for idx, item in enumerate(suggestions, start=1):
        title = item.get("title") or f"×”×¦×¢×” {idx}"
        rows.append({
            "id": f"suggestion_accept_{idx}",
            "title": title[:72],
            "description": "×œ×—×¥ ×œ××™×©×•×¨"
        })
    rows.append({
        "id": "suggestion_reject_all",
        "title": "×“×—×” ××ª ×›×œ ×”×”×¦×¢×•×ª",
        "description": "×‘×œ×™ ×©×™× ×•×™ ×›×¨×’×¢"
    })
    return {
        "type": "list",
        "header": {"type": "text", "text": "×”×¦×¢×•×ª ×—×›××•×ª ×œ×©×™× ×•×™ ×œ×•×–"},
        "body": {"text": "××¤×©×¨ ×œ××©×¨ ×”×¦×¢×” ×‘×œ×—×™×¦×”:"},
        "action": {"button": "×‘×—×™×¨×ª ×”×¦×¢×”", "sections": [{"title": "×”×¦×¢×•×ª", "rows": rows}]}
    }

def format_events_summary(events):
    if not events:
        return "×œ× ××¦××ª×™ ××™×¨×•×¢×™× ×§×¨×•×‘×™× ×‘×™×•××Ÿ ×©×œ×š."
    
    emoji_map = {
        "××™××•×Ÿ": "ğŸ’ª",
        "×¨×™×¦×”": "ğŸƒ",
        "×™×•×’×”": "ğŸ§˜",
        "×©×™× ×”": "ğŸ˜´",
        "×—×‘×¨×™×": "ğŸ‘¥",
        "××©×¤×—×”": "ğŸ ",
        "×¢×‘×•×“×”": "ğŸ’¼",
        "×œ×™××•×“×™×": "ğŸ“š",
        "××˜×œ×•×ª": "ğŸ“",
        "×–××Ÿ": "ğŸ•’",
        "××•×›×œ": "ğŸ•",
        "×¤×’×™×©×”": "ğŸ¤",
        "×˜×™×¤×•×œ": "ğŸ§˜",
        "××¨×¤××”": "ğŸ¥",
        "×¡×™×“×•×¨×™×": "ğŸš²",
        "×“×™×™×˜": "â¤ï¸",
        "×× ×•×—×”": "ğŸ§˜"
    }
    
    lines = ["ğŸ“… *×”× ×” ×”××™×¨×•×¢×™× ×”×§×¨×•×‘×™× ×©×œ×š:*", ""]
    for evt in events:
        start_raw = evt.get("start", {}).get("dateTime") or evt.get("start", {}).get("date")
        summary = evt.get("summary", "××™×¨×•×¢ ×œ×œ× ×›×•×ª×¨×ª")
        
        # Determine emoji
        chosen_emoji = "ğŸ”¹"
        for key, emo in emoji_map.items():
            if key in summary:
                chosen_emoji = emo
                break
        
        # Format time
        try:
            if "T" in start_raw:
                dt = datetime.datetime.fromisoformat(start_raw.replace("Z", "+00:00"))
                dt_il = dt.astimezone(ZoneInfo("Israel"))
                time_str = dt_il.strftime("%H:%M")
                date_str = dt_il.strftime("%d/%m")
                
                today = datetime.datetime.now(ZoneInfo("Israel")).date()
                if dt_il.date() == today:
                    display_start = f"{time_str} (×”×™×•×)"
                elif dt_il.date() == today + datetime.timedelta(days=1):
                    display_start = f"{time_str} (××—×¨)"
                else:
                    display_start = f"{time_str} ({date_str})"
            else:
                # All day event
                dt = datetime.datetime.strptime(start_raw, "%Y-%m-%d")
                date_str = dt.strftime("%d/%m")
                display_start = f"{date_str} (×›×œ ×”×™×•×)"
        except Exception as e:
            print(f"EVENT FORMAT ERROR: {e}")
            display_start = start_raw
            
        lines.append(f"{chosen_emoji} *{summary}* â€” {display_start}")
    
    return "\n".join(lines)

def fetch_events_range(user_id, days=7, max_results=100):
    try:
        service = get_calendar_service(user_id)
        if not service:
            return None
        now = datetime.datetime.utcnow().isoformat() + "Z"
        end = (datetime.datetime.utcnow() + datetime.timedelta(days=days)).isoformat() + "Z"
        events_result = service.events().list(
            calendarId="primary",
            timeMin=now,
            timeMax=end,
            maxResults=max_results,
            singleEvents=True,
            orderBy="startTime"
        ).execute()
        return events_result.get("items", [])
    except Exception as e:
        print(f"FETCH EVENTS RANGE ERROR for {user_id}: {e}")
        return None

def fetch_events_between(user_id, start_date, end_date, max_results=100):
    try:
        service = get_calendar_service(user_id)
        if not service:
            return None
        start_dt = datetime.datetime.combine(start_date, datetime.time.min)
        end_dt = datetime.datetime.combine(end_date, datetime.time.max)
        events_result = service.events().list(
            calendarId="primary",
            timeMin=start_dt.isoformat() + "Z",
            timeMax=end_dt.isoformat() + "Z",
            maxResults=max_results,
            singleEvents=True,
            orderBy="startTime"
        ).execute()
        return events_result.get("items", [])
    except Exception as e:
        print(f"FETCH EVENTS BETWEEN ERROR for {user_id}: {e}")
        return None

def _parse_event_datetime(event_time):
    if not event_time:
        return None
    dt_str = event_time.get("dateTime")
    if dt_str:
        if dt_str.endswith("Z"):
            dt_str = dt_str.replace("Z", "+00:00")
        try:
            return datetime.datetime.fromisoformat(dt_str)
        except Exception:
            return None
    date_str = event_time.get("date")
    if date_str:
        try:
            return datetime.datetime.fromisoformat(date_str)
        except Exception:
            return None
    return None

def _to_local(dt):
    if dt is None:
        return None
    if dt.tzinfo is None:
        return dt
    return dt.astimezone(LOCAL_TZ)

def summarize_calendar_load(events):
    if not events:
        return {
            "count": 0,
            "busy_minutes": 0,
            "overlap_minutes": 0,
            "peak_day": None,
            "per_day": {}
        }
    intervals = []
    per_day = {}
    total_minutes = 0
    for evt in events:
        start = _parse_event_datetime(evt.get("start", {}))
        end = _parse_event_datetime(evt.get("end", {}))
        if not start or not end:
            continue
        start = _to_local(start)
        end = _to_local(end)
        if end <= start:
            continue
        minutes = int((end - start).total_seconds() / 60)
        total_minutes += minutes
        day_key = start.date().isoformat()
        per_day[day_key] = per_day.get(day_key, 0) + minutes
        intervals.append((start, end))

    intervals.sort(key=lambda x: x[0])
    overlap_minutes = 0
    if intervals:
        current_start, current_end = intervals[0]
        for start, end in intervals[1:]:
            if start < current_end:
                overlap = min(current_end, end) - start
                overlap_minutes += int(overlap.total_seconds() / 60)
                if end > current_end:
                    current_end = end
            else:
                current_start, current_end = start, end

    peak_day = None
    if per_day:
        peak_day = max(per_day.items(), key=lambda x: x[1])[0]

    return {
        "count": len(events),
        "busy_minutes": total_minutes,
        "overlap_minutes": overlap_minutes,
        "peak_day": peak_day,
        "per_day": per_day
    }

def build_stress_insights(user_id):
    events = fetch_events_range(user_id, days=7, max_results=100)
    if events is None:
        return None, []
    stats = summarize_calendar_load(events)
    busy_hours = round(stats["busy_minutes"] / 60, 1)
    overlap_minutes = stats["overlap_minutes"]
    peak_day = stats["peak_day"]
    lines = [
        "×¡×™×›×•× ×¢×•××¡ ×œ×©×‘×•×¢ ×”×§×¨×•×‘:",
        f"â€¢ ××™×¨×•×¢×™×: {stats['count']}",
        f"â€¢ ×–××Ÿ ×¢×¡×•×§ ××©×•×¢×¨: {busy_hours} ×©×¢×•×ª",
    ]
    if peak_day:
        lines.append(f"â€¢ ×”×™×•× ×”×¢××•×¡ ×‘×™×•×ª×¨: {peak_day}")
    if overlap_minutes:
        lines.append(f"â€¢ ×—×¤×™×¤×•×ª ×‘×™×Ÿ ××™×¨×•×¢×™×: {overlap_minutes} ×“×§×•×ª")

    insights = []
    stress_flags = 0
    try:
        intervals_data = fetch_intervals_data(user_id)
        survey = intervals_data.get("survey_context", {}) or {}
        mood = survey.get("avg_mood")
        energy = survey.get("avg_energy")
        sleep = intervals_data.get("sleep")
        hrv = intervals_data.get("hrv")
        rhr = intervals_data.get("resting_hr")

        if sleep not in [None, "N/A"] and sleep < 6:
            insights.append("×©×™× ×” ×§×¦×¨×”")
            stress_flags += 1
        if mood not in [None, "N/A"] and mood <= 2:
            insights.append("××¦×‘ ×¨×•×— × ××•×š")
            stress_flags += 1
        if energy not in [None, "N/A"] and energy <= 2:
            insights.append("×× ×¨×’×™×” × ××•×›×”")
            stress_flags += 1
        if rhr not in [None, "N/A"] and rhr >= 75:
            insights.append("×“×•×¤×§ ×× ×•×—×” ×’×‘×•×”")
            stress_flags += 1
        if hrv not in [None, "N/A"] and hrv <= 40:
            insights.append("HRV × ××•×š")
            stress_flags += 1
    except Exception as e:
        print(f"STRESS INSIGHTS ERROR: {e}")

    high_calendar_load = stats["count"] >= 6 or busy_hours >= 10 or overlap_minutes >= 60

    if insights and stats["count"] >= 6:
        lines.append(
            "× ×¨××” ×©×™×© ×©×™×œ×•×‘ ×©×œ ×¢×•××¡ ×‘×™×•××Ÿ ×¢× ×¡×™×× ×™ ×¢×•××¡ ×‘×’×•×£: "
            + " Â· ".join(insights[:4])
        )
        lines.append("×©×•×•×” ×œ×©×§×•×œ ×—×œ×•×Ÿ ×× ×•×—×” ××• ×¤×™×–×•×¨ ×¢×•××¡ ×‘×™××™× ×”×¢××•×¡×™×.")
    elif insights:
        lines.append("×©××ª×™ ×œ×‘ ×œ: " + " Â· ".join(insights[:4]))
    elif stats["count"] >= 6:
        lines.append("×”×™×•××Ÿ × ×¨××” ×“×™ ×¢××•×¡ ×”×©×‘×•×¢. ×× ×ª×¨×¦×”/×™, × ×•×›×œ ×œ×”×•×¡×™×£ ×—×œ×•× ×•×ª ×× ×•×—×”.")

    suggestions = []
    if high_calendar_load or stress_flags >= 2:
        suggestions = build_schedule_suggestions(events, stats)

    return "\n".join(lines), suggestions

def get_events_on_day(events, day_date):
    day_events = []
    for evt in events:
        start = _parse_event_datetime(evt.get("start", {}))
        end = _parse_event_datetime(evt.get("end", {}))
        if not start or not end:
            continue
        start = _to_local(start)
        end = _to_local(end)
        if start.date() == day_date:
            day_events.append((start, end, evt))
    return sorted(day_events, key=lambda x: x[0])

def find_rest_slot(day_events):
    candidate_times = ["12:30", "16:00", "20:00"]
    for time_str in candidate_times:
        slot_start = datetime.datetime.strptime(time_str, "%H:%M").time()
        slot_dt = datetime.datetime.combine(day_events[0][0].date(), slot_start)
        slot_end = slot_dt + datetime.timedelta(minutes=30)
        conflict = False
        for start, end, _ in day_events:
            if start < slot_end and end > slot_dt:
                conflict = True
                break
        if not conflict:
            return time_str
    return None

def build_schedule_suggestions(events, stats):
    suggestions = []
    peak_day = stats.get("peak_day")
    if peak_day:
        try:
            peak_date = datetime.date.fromisoformat(peak_day)
        except Exception:
            peak_date = None
        if peak_date:
            day_events = get_events_on_day(events, peak_date)
            if day_events:
                rest_time = find_rest_slot(day_events)
                if rest_time:
                    suggestions.append({
                        "type": "add_rest",
                        "title": f"×”×•×¡×£ ×—×œ×•×Ÿ ×× ×•×—×” ×‘-{peak_day} ×‘×©×¢×” {rest_time}",
                        "date": peak_day,
                        "time": rest_time,
                        "duration_minutes": 30
                    })

                longest = max(day_events, key=lambda x: (x[1] - x[0]).total_seconds())
                start, end, evt = longest
                duration = int((end - start).total_seconds() / 60)
                if duration >= 45 and evt.get("id"):
                    new_duration = max(30, duration - 15)
                    suggestions.append({
                        "type": "shorten_event",
                        "title": f"×§×™×¦×•×¨ ××™×¨×•×¢: {evt.get('summary', '××™×¨×•×¢')}",
                        "event_id": evt.get("id"),
                        "new_duration": new_duration
                    })
    return suggestions

def save_suggestions(user_id, suggestions):
    db.collection("users").document(_clean_id(user_id)).set({
        "pending_suggestions": suggestions
    }, merge=True)

def clear_suggestions(user_id):
    db.collection("users").document(_clean_id(user_id)).set({
        "pending_suggestions": firestore.DELETE_FIELD
    }, merge=True)

def get_event_by_id(user_id, event_id):
    service = get_calendar_service(user_id)
    if not service:
        return None
    return service.events().get(calendarId="primary", eventId=event_id).execute()

def apply_suggestion_action(user_id, action):
    action_type = action.get("type")
    if action_type == "add_rest":
        date = action.get("date")
        time = action.get("time")
        duration = action.get("duration_minutes", 30)
        if not date or not time:
            return False
        try:
            date_obj = datetime.date.fromisoformat(date)
        except Exception:
            return False
        draft = {
            "title": "×—×œ×•×Ÿ ×× ×•×—×”",
            "date": date_obj,
            "time": time,
            "duration_minutes": duration
        }
        return create_calendar_event(user_id, draft) is not None
    if action_type == "shorten_event":
        event_id = action.get("event_id")
        new_duration = action.get("new_duration")
        if not event_id or not new_duration:
            return False
        evt = get_event_by_id(user_id, event_id)
        if not evt:
            return False
        start = _parse_event_datetime(evt.get("start", {}))
        if not start:
            return False
        start = _to_local(start)
        end_dt = start + datetime.timedelta(minutes=int(new_duration))
        service = get_calendar_service(user_id)
        if not service:
            return False
        service.events().patch(
            calendarId="primary",
            eventId=event_id,
            body={"end": {"dateTime": end_dt.isoformat(), "timeZone": "Asia/Jerusalem"}}
        ).execute()
        return True
    return False

def update_event_from_site(user_id, event_id, changes):
    evt = get_event_by_id(user_id, event_id)
    if not evt:
        return False
    draft = build_event_update_draft(evt)
    draft["pending_changes"] = changes
    return confirm_event_update(user_id, draft)

def handle_pending_suggestions(sender, text, user_doc):
    suggestions = user_doc.get("pending_suggestions") or []
    if not suggestions:
        return False
    if any(word in text for word in ["×“×—×”", "×œ× ×ª×•×“×”", "×¢×–×•×‘"]):
        clear_suggestions(sender)
        send_wa(sender, "×”×‘× ×ª×™, ×œ× ××‘×¦×¢ ×©×™× ×•×™ ×›×¨×’×¢.")
        return True
    m = re.search(r"××©×¨\s*(\d+)", text)
    if m:
        idx = int(m.group(1)) - 1
        if 0 <= idx < len(suggestions):
            success = apply_suggestion_action(sender, suggestions[idx])
            clear_suggestions(sender)
            if success:
                send_wa(sender, "âœ… ×‘×™×¦×¢×ª×™ ××ª ×”×”×¦×¢×” ×©×‘×—×¨×ª.")
            else:
                send_wa(sender, "×œ× ×”×¦×œ×—×ª×™ ×œ×‘×¦×¢ ××ª ×”×”×¦×¢×”. × ×¡×”/×™ ×©×•×‘ ×‘×¢×•×“ ×¨×’×¢.")
            return True
    return False

EVENT_INTENT_PHRASES = [
    "×ª×•×¡×™×£ ××™×¨×•×¢",
    "×”×•×¡×£ ××™×¨×•×¢",
    "×§×‘×¢ ××™×¨×•×¢",
    "×§×‘×¢ ×¤×’×™×©×”",
    "×ª×•×¡×™×£ ×¤×’×™×©×”",
    "×ª×¨×©×•× ×‘×™×•××Ÿ",
    "×œ×”×•×¡×™×£ ×œ×™×•××Ÿ",
    "×œ×§×‘×•×¢ ×‘×™×•××Ÿ"
]

def is_event_intent(text):
    if not text:
        return False
    return any(phrase in text for phrase in EVENT_INTENT_PHRASES)

def parse_date_from_text(text):
    if not text:
        return None
    today = datetime.date.today()
    if "××—×¨×ª×™×™×" in text:
        return today + datetime.timedelta(days=2)
    if "××—×¨" in text:
        return today + datetime.timedelta(days=1)
    if "×”×™×•×" in text:
        return today
    m = re.search(r"(\d{1,2})[./-](\d{1,2})(?:[./-](\d{2,4}))?", text)
    if m:
        day = int(m.group(1))
        month = int(m.group(2))
        year = m.group(3)
        if year:
            year = int(year)
            if year < 100:
                year += 2000
        else:
            year = today.year
        try:
            return datetime.date(year, month, day)
        except Exception:
            return None
    weekdays = {
        "×¨××©×•×Ÿ": 6,
        "×©× ×™": 0,
        "×©×œ×™×©×™": 1,
        "×¨×‘×™×¢×™": 2,
        "×—××™×©×™": 3,
        "×©×™×©×™": 4,
        "×©×‘×ª": 5
    }
    for name, target in weekdays.items():
        if re.search(rf"(?:×™×•×\s+)?{name}", text):
            today_weekday = today.weekday()
            delta = (target - today_weekday + 7) % 7
            if delta == 0:
                delta = 7
            return today + datetime.timedelta(days=delta)
    return None

def parse_date_range_from_text(text):
    if not text:
        return None, None
    today = datetime.date.today()
    if "×©×‘×•×¢ ×”×‘×" in text:
        start = today + datetime.timedelta(days=(7 - today.weekday()))
        end = start + datetime.timedelta(days=6)
        return start, end
    if "×”×©×‘×•×¢" in text:
        start = today
        end = today + datetime.timedelta(days=6)
        return start, end
    m = re.search(r"(\d{1,2}[./-]\d{1,2}(?:[./-]\d{2,4})?)\s*(?:×¢×“|×¢×“|×œ|-\s*)\s*(\d{1,2}[./-]\d{1,2}(?:[./-]\d{2,4})?)", text)
    if m:
        start = parse_date_from_text(m.group(1))
        end = parse_date_from_text(m.group(2))
        return start, end
    single = parse_date_from_text(text)
    if single:
        return single, single
    return None, None

def parse_time_from_text(text):
    if not text:
        return None
    m = re.search(r"\b([01]?\d|2[0-3])[:.](\d{2})\b", text)
    if not m:
        m = re.search(r"(?:×‘×©×¢×”|×‘-)\s*([01]?\d|2[0-3])(?:[:.](\d{2}))?", text)
    if not m:
        return None
    hour = int(m.group(1))
    minute = int(m.group(2)) if m.group(2) else 0
    if any(word in text for word in ["×‘×¢×¨×‘", "×‘×œ×™×œ×”", "××—×”\"×¦", "××—×¨ ×”×¦×”×¨×™×™×"]):
        if hour < 12:
            hour += 12
    if "×‘×‘×•×§×¨" in text and hour == 12:
        hour = 0
    return f"{hour:02d}:{minute:02d}"

def parse_duration_minutes(text):
    if not text:
        return None
    if "×—×¦×™ ×©×¢×”" in text:
        return 30
    if "×¨×‘×¢ ×©×¢×”" in text:
        return 15
    m = re.search(r"(\d{1,3})\s*×“×§×•×ª?", text)
    if m:
        return int(m.group(1))
    m = re.search(r"(\d{1,2})\s*×©×¢×•×ª?", text)
    if m:
        return int(m.group(1)) * 60
    return None

def parse_reminder_minutes(text):
    if not text:
        return None
    m = re.search(r"×ª×–×›×•×¨×ª\s*(?:×©×œ\s*)?(\d{1,3})\s*×“×§×•×ª", text)
    if m:
        return int(m.group(1))
    m = re.search(r"×ª×–×›×™×¨.*?(\d{1,3})\s*×“×§×•×ª", text)
    if m:
        return int(m.group(1))
    return None

def parse_remove_reminder(text):
    if not text:
        return False
    return any(phrase in text for phrase in ["×‘×œ×™ ×ª×–×›×•×¨×ª", "×‘×˜×œ ×ª×–×›×•×¨×ª", "×œ×œ× ×ª×–×›×•×¨×ª", "×ª×–×›×•×¨×ª ×œ×"])

def parse_location(text):
    if not text:
        return None
    m = re.search(r"(?:×‘×›×ª×•×‘×ª|×‘××§×•×|×‘-)\s*([^\n,]+)", text)
    if m:
        return m.group(1).strip()
    return None

def parse_title_update(text):
    if not text:
        return None
    m = re.search(r"(?:×›×•×ª×¨×ª ×—×“×©×”|×©× ×—×“×©|×›×•×ª×¨×ª|×©× ×” ×›×•×ª×¨×ª ×œ|×©× ×” ××ª ×”×›×•×ª×¨×ª ×œ)\s*[:\-]?\s*([^\n,]+)", text)
    if m:
        return m.group(1).strip()
    return None

def parse_title(text):
    if not text:
        return None
    m = re.search(r"[\"×´×³']([^\"×´×³']{2,60})[\"×´×³']", text)
    if m:
        return m.group(1).strip()
    m = re.search(r"(?:×¤×’×™×©×” ×¢×|××¤×’×© ×¢×)\s+([^\n,]+)", text)
    if m:
        return f"×¤×’×™×©×” ×¢× {m.group(1).strip()}"
    m = re.search(r"(?:×§×‘×¢|×ª×•×¡×™×£|×”×•×¡×£|×œ×”×•×¡×™×£|×œ×§×‘×•×¢|×ª×¨×©×•×)\s+(?:××™×¨×•×¢|×¤×’×™×©×”)?\s*([^\n,]+)", text)
    if m:
        candidate = m.group(1).strip()
        candidate = re.split(r"\b(?:×‘×©×¢×”|××—×¨|×”×™×•×|×‘×ª××¨×™×š|×‘×™×•×|×œ××©×š)\b", candidate)[0].strip()
        if candidate:
            return candidate
    return None

def extract_event_fields(text):
    fields = {
        "title": parse_title(text),
        "date": parse_date_from_text(text),
        "time": parse_time_from_text(text),
        "duration_minutes": parse_duration_minutes(text),
        "location": parse_location(text),
        "reminder_minutes": parse_reminder_minutes(text)
    }
    if fields.get("location") and GOOGLE_MAPS_API_KEY:
        lat, lng, formatted = geocode_address(fields["location"])
        if formatted:
            fields["location"] = formatted
    return fields

def get_missing_event_fields(draft):
    required = ["title", "date", "time", "duration_minutes"]
    return [field for field in required if not draft.get(field)]

def get_next_event_question(field):
    if field == "title":
        return "××” ×”×›×•×ª×¨×ª ×”××“×•×™×§×ª ×©×œ ×”××™×¨×•×¢?"
    if field == "date":
        return "×‘××™×–×” ×ª××¨×™×š? ××¤×©×¨ ×’× ×œ×›×ª×•×‘ '×”×™×•×' / '××—×¨' / ×™×•× ×‘×©×‘×•×¢."
    if field == "time":
        return "×‘××™×–×• ×©×¢×” ×œ×”×ª×—×™×œ? (×œ××©×œ 09:30)"
    if field == "duration_minutes":
        return "×›××” ×–××Ÿ ×”××™×¨×•×¢? (×œ××©×œ 45 ×“×§×•×ª ××• ×©×¢×”)"
    return "××¤×©×¨ ×œ×ª×ª ×¢×•×“ ×¤×¨×˜×™× ×¢×œ ×”××™×¨×•×¢?"

def save_event_draft(user_id, draft):
    payload = dict(draft)
    if isinstance(payload.get("date"), datetime.date):
        payload["date"] = payload["date"].isoformat()
    db.collection("users").document(_clean_id(user_id)).set({
        "pending_event": payload
    }, merge=True)

def clear_event_draft(user_id):
    db.collection("users").document(_clean_id(user_id)).set({
        "pending_event": firestore.DELETE_FIELD
    }, merge=True)

def normalize_event_draft(draft):
    if not draft:
        return {}
    date_val = draft.get("date")
    if isinstance(date_val, str):
        try:
            draft["date"] = datetime.date.fromisoformat(date_val)
        except Exception:
            pass
    elif isinstance(date_val, datetime.datetime):
        draft["date"] = date_val.date()
    return draft

def normalize_event_update(draft):
    if not draft:
        return {}
    for key in ["start", "end"]:
        val = draft.get(key)
        if isinstance(val, str):
            try:
                if val.endswith("Z"):
                    val = val.replace("Z", "+00:00")
                draft[key] = datetime.datetime.fromisoformat(val)
            except Exception:
                pass
    return draft

def start_event_edit_flow(sender, user_doc, text=None):
    if is_group(sender):
        send_wa(sender, "××¤×©×¨ ×œ×¢×¨×•×š ××™×¨×•×¢×™× ×‘×™×•××Ÿ ×¨×§ ×‘×¤×¨×˜×™. ×›×ª×•×‘/×›×ª×‘×™ ×œ×™ ×‘×”×•×“×¢×” ×¤×¨×˜×™×ª.")
        return True
    creds = load_calendar_credentials(sender)
    if not creds:
        link = calendar_connect_url(sender)
        send_wa(sender, f"×›×“×™ ×œ×¢×¨×•×š ××™×¨×•×¢ ×‘×™×•××Ÿ, ×¦×¨×™×š ×—×™×‘×•×¨. ×”×™×›× ×¡/×™ ×œ×§×™×©×•×¨:\n{link}")
        return True
    start_date, end_date = parse_date_range_from_text(text or "")
    if start_date and end_date:
        events = fetch_events_between(sender, start_date, end_date, max_results=15)
    else:
        events = fetch_upcoming_events(sender, max_results=8)
    if not events:
        send_wa(sender, "×œ× ××¦××ª×™ ××™×¨×•×¢×™× ×§×¨×•×‘×™× ×œ×¢×¨×™×›×”.")
        return True
    menu = get_edit_event_menu(events)
    if not menu:
        send_wa(sender, "×œ× ××¦××ª×™ ××™×¨×•×¢×™× ×–××™× ×™× ×œ×¢×¨×™×›×”.")
        return True
    send_wa(sender, "×‘×—×¨/×™ ××™×¨×•×¢ ×œ×¢×¨×™×›×”:", interactive_list=menu)
    return True

def build_event_update_draft(evt):
    start = _parse_event_datetime(evt.get("start", {}))
    end = _parse_event_datetime(evt.get("end", {}))
    return {
        "event_id": evt.get("id"),
        "title": evt.get("summary", "××™×¨×•×¢ ×œ×œ× ×›×•×ª×¨×ª"),
        "location": evt.get("location"),
        "start": start.isoformat() if start else None,
        "end": end.isoformat() if end else None,
        "pending_changes": {}
    }

def prompt_event_changes(sender):
    send_wa(
        sender,
        "××” ×ª×¨×¦×”/×™ ×œ×©× ×•×ª? ××¤×©×¨ ×œ×›×ª×•×‘ ×œ××©×œ:\n"
        "â€¢ ×ª××¨×™×š 15/2\n"
        "â€¢ ×©×¢×” 09:30\n"
        "â€¢ ××©×š 45 ×“×§×•×ª\n"
        "â€¢ ×›×•×ª×¨×ª ×—×“×©×”: ×¤×’×™×©×” ×¢× ×“× ×™\n"
        "â€¢ ××§×•×: ×‘×™×ª ×§×¤×”\n"
        "â€¢ ×ª×–×›×•×¨×ª 30 ×“×§×•×ª / ×‘×œ×™ ×ª×–×›×•×¨×ª"
    )

def apply_update_fields(draft, text):
    changes = draft.get("pending_changes", {})
    new_date = parse_date_from_text(text)
    new_time = parse_time_from_text(text)
    new_duration = parse_duration_minutes(text)
    new_location = parse_location(text)
    new_title = parse_title_update(text)
    new_reminder = parse_reminder_minutes(text)
    remove_reminder = parse_remove_reminder(text)

    if new_date:
        changes["date"] = new_date.isoformat()
    if new_time:
        changes["time"] = new_time
    if new_duration:
        changes["duration_minutes"] = new_duration
    if new_location:
        if GOOGLE_MAPS_API_KEY:
            lat, lng, formatted = geocode_address(new_location)
            if formatted:
                new_location = formatted
        changes["location"] = new_location
    if new_title:
        changes["title"] = new_title[:80]
    if new_reminder is not None:
        changes["reminder_minutes"] = int(new_reminder)
    if remove_reminder:
        changes["reminder_minutes"] = None
    draft["pending_changes"] = changes
    return draft

def build_update_summary(draft):
    changes = draft.get("pending_changes", {})
    lines = ["××¦××ª×™ ××ª ×”×©×™× ×•×™×™× ×”×‘××™×:"]
    if "title" in changes:
        lines.append(f"â€¢ ×›×•×ª×¨×ª: {changes['title']}")
    if "date" in changes:
        lines.append(f"â€¢ ×ª××¨×™×š: {changes['date']}")
    if "time" in changes:
        lines.append(f"â€¢ ×©×¢×”: {changes['time']}")
    if "duration_minutes" in changes:
        lines.append(f"â€¢ ××©×š: {changes['duration_minutes']} ×“×§×•×ª")
    if "location" in changes:
        lines.append(f"â€¢ ××§×•×: {changes['location']}")
    if "reminder_minutes" in changes:
        if changes["reminder_minutes"] is None:
            lines.append("â€¢ ×ª×–×›×•×¨×ª: ×œ×œ×")
        else:
            lines.append(f"â€¢ ×ª×–×›×•×¨×ª: {changes['reminder_minutes']} ×“×§×•×ª ×œ×¤× ×™")
    lines.append("×œ××©×¨ ××ª ×”×¢×“×›×•×Ÿ? (×›×ª×•×‘/×›×ª×‘×™ '××©×¨' ××• '×‘×˜×œ')")
    return "\n".join(lines)

def confirm_event_update(sender, draft):
    service = get_calendar_service(sender)
    if not service:
        return False
    draft = normalize_event_update(draft)
    changes = draft.get("pending_changes", {})
    if not changes:
        return False

    start = draft.get("start")
    end = draft.get("end")
    if isinstance(start, str):
        start = None
    if isinstance(end, str):
        end = None

    if start and end:
        start = _to_local(start)
        end = _to_local(end)

    if "date" in changes or "time" in changes or "duration_minutes" in changes:
        if not start or not end:
            return False
        current_duration = int((end - start).total_seconds() / 60)
        new_date = changes.get("date")
        new_time = changes.get("time")
        new_duration = int(changes.get("duration_minutes", current_duration))

        base_date = start.date().isoformat()
        base_time = start.strftime("%H:%M")
        if new_date:
            base_date = new_date
        if new_time:
            base_time = new_time
        start_dt = datetime.datetime.strptime(f"{base_date} {base_time}", "%Y-%m-%d %H:%M")
        end_dt = start_dt + datetime.timedelta(minutes=new_duration)
    else:
        start_dt = start
        end_dt = end

    body = {}
    if "title" in changes:
        body["summary"] = changes["title"]
    if "location" in changes:
        body["location"] = changes["location"]
    if start_dt and end_dt:
        body["start"] = {"dateTime": start_dt.isoformat(), "timeZone": "Asia/Jerusalem"}
        body["end"] = {"dateTime": end_dt.isoformat(), "timeZone": "Asia/Jerusalem"}
    if "reminder_minutes" in changes:
        if changes["reminder_minutes"] is None:
            body["reminders"] = {"useDefault": False, "overrides": []}
        else:
            body["reminders"] = {
                "useDefault": False,
                "overrides": [{"method": "popup", "minutes": int(changes["reminder_minutes"])}]
            }

    if not body:
        return False

    service.events().patch(
        calendarId="primary",
        eventId=draft["event_id"],
        body=body
    ).execute()
    return True

def save_event_update_draft(user_id, draft):
    db.collection("users").document(_clean_id(user_id)).set({
        "pending_event_update": draft
    }, merge=True)

def clear_event_update_draft(user_id):
    db.collection("users").document(_clean_id(user_id)).set({
        "pending_event_update": firestore.DELETE_FIELD
    }, merge=True)

def create_calendar_event(user_id, draft):
    try:
        service = get_calendar_service(user_id)
        if not service:
            print(f"DEBUG: Calendar service not available for {user_id}")
            return None
            
        # Parse date and time correctly
        date_obj = draft['date']
        if isinstance(date_obj, str):
            date_obj = datetime.date.fromisoformat(date_obj)
            
        start_dt = datetime.datetime.combine(date_obj, datetime.datetime.strptime(draft['time'], "%H:%M").time())
        end_dt = start_dt + datetime.timedelta(minutes=int(draft.get("duration_minutes", 60)))
        
        event_body = {
            "summary": draft["title"],
            "start": {"dateTime": start_dt.isoformat(), "timeZone": "Asia/Jerusalem"},
            "end": {"dateTime": end_dt.isoformat(), "timeZone": "Asia/Jerusalem"}
        }
        if draft.get("location"):
            event_body["location"] = draft["location"]
        if draft.get("reminder_minutes"):
            event_body["reminders"] = {
                "useDefault": False,
                "overrides": [{"method": "popup", "minutes": int(draft["reminder_minutes"])}]
            }
        
        created_event = service.events().insert(calendarId="primary", body=event_body).execute()
        print(f"DEBUG: Successfully created event for {user_id}: {created_event.get('id')}")
        return created_event
    except Exception as e:
        print(f"CREATE CALENDAR EVENT ERROR for {user_id}: {e}")
        return None

def handle_pending_event(sender, text, user_doc):
    if any(word in text for word in ["×‘×˜×œ", "×‘×™×˜×•×œ", "×¢×¦×•×¨"]):
        clear_event_draft(sender)
        send_wa(sender, "×‘×™×˜×œ×ª×™ ××ª ×™×¦×™×¨×ª ×”××™×¨×•×¢. ×× ×ª×¨×¦×”/×™ ×œ×§×‘×•×¢ ×©×•×‘, ×¤×©×•×˜ ×›×ª×•×‘/×›×ª×‘×™ ×”×•×“×¢×” ×—×“×©×”.")
        return True
    draft = normalize_event_draft(user_doc.get("pending_event", {}) or {})
    expected = draft.get("last_question")
    if expected == "title":
        title = parse_title(text) or text.strip()
        draft["title"] = title[:80]
    elif expected == "date":
        date = parse_date_from_text(text)
        if not date:
            send_wa(sender, "×œ× ×”×¦×œ×—×ª×™ ×œ×”×‘×™×Ÿ ××ª ×”×ª××¨×™×š. ××¤×©×¨ ×œ×›×ª×•×‘ ×œ××©×œ 14/2 ××• '××—×¨'.")
            return True
        draft["date"] = date
    elif expected == "time":
        time = parse_time_from_text(text)
        if not time:
            send_wa(sender, "×œ× ×”×‘× ×ª×™ ××ª ×”×©×¢×”. × ×¡×”/×™ ×‘×¤×•×¨××˜ 09:30.")
            return True
        draft["time"] = time
    elif expected == "duration_minutes":
        duration = parse_duration_minutes(text)
        if not duration:
            send_wa(sender, "×œ× ×”×‘× ×ª×™ ××ª ××©×š ×”×–××Ÿ. ××¤×©×¨ ×œ×›×ª×•×‘ '45 ×“×§×•×ª' ××• '×©×¢×”'.")
            return True
        draft["duration_minutes"] = duration

    missing = get_missing_event_fields(draft)
    if missing:
        next_field = missing[0]
        draft["last_question"] = next_field
        save_event_draft(sender, draft)
        send_wa(sender, get_next_event_question(next_field))
        return True

    created = create_calendar_event(sender, draft)
    if created:
        clear_event_draft(sender)
        confirmation = (
            f"âœ… ×™×¦×¨×ª×™ ××™×¨×•×¢ ×‘×™×•××Ÿ:\n"
            f"â€¢ {draft['title']}\n"
            f"â€¢ {draft['date'].isoformat()} ×‘×©×¢×” {draft['time']}\n"
            f"â€¢ ××©×š: {draft['duration_minutes']} ×“×§×•×ª"
        )
        if draft.get("location"):
            confirmation += f"\nâ€¢ ××§×•×: {draft['location']}"
        send_wa(sender, confirmation)
        return True

    send_wa(sender, "×œ× ×”×¦×œ×—×ª×™ ×œ×™×¦×•×¨ ××ª ×”××™×¨×•×¢. ×•×“×/×™ ×©×”×™×•××Ÿ ××—×•×‘×¨ ×•× ×¡×”/×™ ×©×•×‘.")
    return True

def handle_event_intent(sender, text, user_doc):
    if is_group(sender):
        send_wa(sender, "××¤×©×¨ ×œ×§×‘×•×¢ ××™×¨×•×¢×™× ×‘×™×•××Ÿ ×¨×§ ×‘×¤×¨×˜×™. ×›×ª×•×‘/×›×ª×‘×™ ×œ×™ ×‘×”×•×“×¢×” ×¤×¨×˜×™×ª.")
        return True
    creds = load_calendar_credentials(sender)
    if not creds:
        link = calendar_connect_url(sender)
        send_wa(sender, f"×›×“×™ ×œ×§×‘×•×¢ ××™×¨×•×¢ ×‘×™×•××Ÿ, ×§×•×“× ×¦×¨×™×š ×—×™×‘×•×¨. ×”×™×›× ×¡/×™ ×œ×§×™×©×•×¨:\n{link}")
        return True

    draft = extract_event_fields(text)
    missing = get_missing_event_fields(draft)
    if missing:
        next_field = missing[0]
        draft["last_question"] = next_field
        save_event_draft(sender, draft)
        send_wa(sender, get_next_event_question(next_field))
        return True

    created = create_calendar_event(sender, draft)
    if created:
        confirmation = (
            f"âœ… ×™×¦×¨×ª×™ ××™×¨×•×¢ ×‘×™×•××Ÿ:\n"
            f"â€¢ {draft['title']}\n"
            f"â€¢ {draft['date'].isoformat()} ×‘×©×¢×” {draft['time']}\n"
            f"â€¢ ××©×š: {draft['duration_minutes']} ×“×§×•×ª"
        )
        if draft.get("location"):
            confirmation += f"\nâ€¢ ××§×•×: {draft['location']}"
        send_wa(sender, confirmation)
        return True

    send_wa(sender, "×œ× ×”×¦×œ×—×ª×™ ×œ×™×¦×•×¨ ××ª ×”××™×¨×•×¢. × ×¡×”/×™ ×©×•×‘ ×¢×•×“ ×¨×’×¢.")
    return True

def set_workout_active(user_id, workout_id):
    if not workout_id:
        return
    db.collection("users").document(_clean_id(user_id)).set({
        "workout_active": workout_id,
        "workout_active_at": datetime.datetime.now().isoformat()
    }, merge=True)

def store_workout_recommendations(user_id, workouts, state_key):
    if not workouts:
        return
    payload = {
        "last_workout_state": state_key,
        "last_workout_recommendations": [
            {
                "id": w.get("id"),
                "name": w.get("name"),
                "short_description": w.get("short_description"),
                "duration_minutes": w.get("duration_minutes"),
                "intensity": w.get("intensity")
            }
            for w in workouts[:10]
        ],
        "last_workout_recommended_at": datetime.datetime.now().isoformat()
    }
    db.collection("users").document(_clean_id(user_id)).set(payload, merge=True)

def clear_workout_active(user_id):
    db.collection("users").document(_clean_id(user_id)).set({
        "workout_active": firestore.DELETE_FIELD,
        "workout_active_at": firestore.DELETE_FIELD,
        "active_workout_id": firestore.DELETE_FIELD
    }, merge=True)

def get_vision_client():
    global vision_client
    if vision_client is None:
        vision_client = vision.ImageAnnotatorClient()
    return vision_client

def detect_landmark_location(image_bytes):
    """Returns (lat, lng, name) from landmark detection if available."""
    try:
        client = get_vision_client()
        image = vision.Image(content=image_bytes)
        response = client.landmark_detection(image=image)
        landmarks = response.landmark_annotations or []
        if not landmarks:
            return None, None, None
        landmark = landmarks[0]
        if not landmark.locations:
            return None, None, landmark.description
        lat_lng = landmark.locations[0].lat_lng
        return lat_lng.latitude, lat_lng.longitude, landmark.description
    except Exception as e:
        print(f"VISION ERROR: {e}")
        return None, None, None

def reverse_geocode(lat, lng):
    if not GOOGLE_MAPS_API_KEY:
        return None
    try:
        res = requests.get(
            "https://maps.googleapis.com/maps/api/geocode/json",
            params={"latlng": f"{lat},{lng}", "key": GOOGLE_MAPS_API_KEY},
            timeout=10
        )
        if res.status_code == 200:
            data = res.json()
            results = data.get("results", [])
            if results:
                return results[0].get("formatted_address")
    except Exception as e:
        print(f"GEOCODE ERROR: {e}")
    return None

def geocode_address(address):
    if not GOOGLE_MAPS_API_KEY:
        return None, None, None
    try:
        res = requests.get(
            "https://maps.googleapis.com/maps/api/geocode/json",
            params={"address": address, "key": GOOGLE_MAPS_API_KEY},
            timeout=10
        )
        if res.status_code == 200:
            data = res.json()
            results = data.get("results", [])
            if results:
                loc = results[0]["geometry"]["location"]
                return loc["lat"], loc["lng"], results[0].get("formatted_address")
    except Exception as e:
        print(f"GEOCODE ADDRESS ERROR: {e}")
    return None, None, None

def estimate_target_km(route_mode, target_minutes=None, target_km=None):
    if target_km:
        return target_km
    if not target_minutes:
        return 2
    pace_km_per_min = 0.08
    if route_mode == "run":
        pace_km_per_min = 0.15
    elif route_mode == "bike":
        pace_km_per_min = 0.3
    return round(target_minutes * pace_km_per_min, 2)

def compute_destination(lat, lng, target_km):
    if target_km is None:
        return None, None
    delta_lat = target_km / 111.0
    delta_lng = delta_lat / 2
    return lat + delta_lat, lng + delta_lng

def build_route_link(origin, destination, route_mode, waypoint=None, loop_back=False):
    travelmode = "walking"
    if route_mode == "bike":
        travelmode = "bicycling"
    elif route_mode == "run":
        travelmode = "walking"
    dest = origin if loop_back else destination
    url = (
        "https://www.google.com/maps/dir/?api=1"
        f"&origin={origin[0]},{origin[1]}"
        f"&destination={dest[0]},{dest[1]}"
        f"&travelmode={travelmode}"
    )
    if waypoint:
        url += f"&waypoints={waypoint[0]},{waypoint[1]}"
    return url

def build_directions(origin, destination, route_mode, loop_back=False, waypoint=None):
    if not GOOGLE_MAPS_API_KEY:
        return None
    travelmode = "walking"
    if route_mode == "bike":
        travelmode = "bicycling"
    elif route_mode == "run":
        travelmode = "walking"
    dest = origin if loop_back else destination
    try:
        params = {
            "origin": f"{origin[0]},{origin[1]}",
            "destination": f"{dest[0]},{dest[1]}",
            "mode": travelmode,
            "key": GOOGLE_MAPS_API_KEY
        }
        if waypoint:
            params["waypoints"] = f"{waypoint[0]},{waypoint[1]}"
        res = requests.get(
            "https://maps.googleapis.com/maps/api/directions/json",
            params=params,
            timeout=10
        )
        if res.status_code == 200:
            data = res.json()
            if data.get("routes"):
                return data
    except Exception as e:
        print(f"DIRECTIONS ERROR: {e}")
    return None

REGULATION_AUDIO_SCRIPTS = {
    "breath": {
        "male": (
            "<speak>"
            "×”×™×™. <break time=\"400ms\"/> × ×ª×—×™×œ ×™×—×“ ×ª×¨×’×™×œ × ×©×™××” ××¨×‘×¢, ×©×‘×¢, ×©××•× ×”. "
            "<break time=\"400ms\"/> ×©×‘ ×‘× ×•×—×•×ª. "
            "<break time=\"300ms\"/> ×©××™×¤×” ×“×¨×š ×”××£ ×‘××©×š ××¨×‘×¢. "
            "<break time=\"400ms\"/> ×¢×¦×•×¨ ××ª ×”××•×•×™×¨ ×‘××©×š ×©×‘×¢. "
            "<break time=\"400ms\"/> × ×©×™×¤×” ××™×˜×™×ª ×“×¨×š ×”×¤×” ×‘××©×š ×©××•× ×”. "
            "<break time=\"400ms\"/> × ×—×–×•×¨ ×¢×œ ×–×” ××¨×‘×¢ ×¤×¢××™×. "
            "<break time=\"300ms\"/> ××•×›×Ÿ? ×‘×•× × ×ª×—×™×œ ×™×—×“."
            "</speak>"
        ),
        "female": (
            "<speak>"
            "×”×™×™. <break time=\"400ms\"/> × ×ª×—×™×œ ×™×—×“ ×ª×¨×’×™×œ × ×©×™××” ××¨×‘×¢, ×©×‘×¢, ×©××•× ×”. "
            "<break time=\"400ms\"/> ×©×‘×™ ×‘× ×•×—×•×ª. "
            "<break time=\"300ms\"/> ×©××™×¤×” ×“×¨×š ×”××£ ×‘××©×š ××¨×‘×¢. "
            "<break time=\"400ms\"/> ×¢×¦×¨×™ ××ª ×”××•×•×™×¨ ×‘××©×š ×©×‘×¢. "
            "<break time=\"400ms\"/> × ×©×™×¤×” ××™×˜×™×ª ×“×¨×š ×”×¤×” ×‘××©×š ×©××•× ×”. "
            "<break time=\"400ms\"/> × ×—×–×•×¨ ×¢×œ ×–×” ××¨×‘×¢ ×¤×¢××™×. "
            "<break time=\"300ms\"/> ××•×›× ×”? ×‘×•××™ × ×ª×—×™×œ ×™×—×“."
            "</speak>"
        )
    },
    "ground": {
        "male": (
            "<speak>"
            "×‘×•× × ×¢×©×” ×ª×¨×’×™×œ ×§×¨×§×•×¢ ×—××©, ××¨×‘×¢, ×©×œ×•×©, ×©×ª×™×™×, ××—×ª. "
            "<break time=\"300ms\"/> ×”×¡×ª×›×œ ×¡×‘×™×‘. "
            "<break time=\"300ms\"/> ×—××™×©×” ×“×‘×¨×™× ×©××ª×” ×¨×•××”. "
            "<break time=\"300ms\"/> ××¨×‘×¢×” ×“×‘×¨×™× ×©××¤×©×¨ ×œ×’×¢×ª ×‘×”×. "
            "<break time=\"300ms\"/> ×©×œ×•×©×” ×“×‘×¨×™× ×©××ª×” ×©×•××¢. "
            "<break time=\"300ms\"/> ×©× ×™ ×“×‘×¨×™× ×©××ª×” ××¨×™×—. "
            "<break time=\"300ms\"/> ×•×“×‘×¨ ××—×“ ×©××ª×” ×˜×•×¢×. "
            "<break time=\"400ms\"/> ×§×— ×¨×’×¢. ×–×” ×¢×•×–×¨ ×œ××¢×¨×›×ª ×œ×”×¨×’×™×© ×‘×˜×•×—×” ×™×•×ª×¨."
            "</speak>"
        ),
        "female": (
            "<speak>"
            "×‘×•××™ × ×¢×©×” ×ª×¨×’×™×œ ×§×¨×§×•×¢ ×—××©, ××¨×‘×¢, ×©×œ×•×©, ×©×ª×™×™×, ××—×ª. "
            "<break time=\"300ms\"/> ×”×¡×ª×›×œ×™ ×¡×‘×™×‘. "
            "<break time=\"300ms\"/> ×—××™×©×” ×“×‘×¨×™× ×©××ª ×¨×•××”. "
            "<break time=\"300ms\"/> ××¨×‘×¢×” ×“×‘×¨×™× ×©××¤×©×¨ ×œ×’×¢×ª ×‘×”×. "
            "<break time=\"300ms\"/> ×©×œ×•×©×” ×“×‘×¨×™× ×©××ª ×©×•××¢×ª. "
            "<break time=\"300ms\"/> ×©× ×™ ×“×‘×¨×™× ×©××ª ××¨×™×—×”. "
            "<break time=\"300ms\"/> ×•×“×‘×¨ ××—×“ ×©××ª ×˜×•×¢××ª. "
            "<break time=\"400ms\"/> ×§×—×™ ×¨×’×¢. ×–×” ×¢×•×–×¨ ×œ××¢×¨×›×ª ×œ×”×¨×’×™×© ×‘×˜×•×—×” ×™×•×ª×¨."
            "</speak>"
        )
    }
}

def maybe_send_regulation_audio(to, text):
    """Sends a TTS-guided regulation exercise and asks for a voice reply."""
    key = None
    if "× ×©×™××”" in text:
        key = "breath"
    elif any(k in text for k in ["×§×¨×§×•×¢", "5 ×“×‘×¨×™×", "5-4-3-2-1", "5-4-3"]):
        key = "ground"
    
    if not key:
        return False
    user_doc = get_user_doc(to)
    script = REGULATION_AUDIO_SCRIPTS[key].get(
        "female" if user_doc.get("gender") == "female" else "male"
    )
    audio_bytes = tts_generate_audio(script)
    if audio_bytes:
        media_id = upload_wa_media(audio_bytes, f"{key}.ogg", "audio/ogg")
        if media_id:
            send_wa_audio(to, media_id)
            send_wa(to, "×›×©×ª×¡×™×™×/×™, ×©×œ×—/×™ ×œ×™ ×”×§×œ×˜×” ×§×¦×¨×” ××™×š ×”×™×” ×œ×š. ğŸ¤")
            return True
    
    # Fallback to text if TTS or upload fails
    send_wa(to, "×ª×¨×’×™×œ ×•×™×¡×•×ª ×–××™×Ÿ. ×›×ª×•×‘/×›×ª×‘×™ ×œ×™ ×× ×ª×¨×¦×”/×™ ×©× ×©×œ×— ×©×•×‘.")
    return True

WORKOUT_CATALOG = None

def load_workout_catalog(user_id=None):
    """Loads the workouts catalog, merging global and user-specific workouts."""
    global WORKOUT_CATALOG
    catalog = []
    
    # Load base catalog (cached)
    if WORKOUT_CATALOG is not None:
        catalog = list(WORKOUT_CATALOG)
    else:
        try:
            with open(WORKOUTS_CATALOG_PATH, "r", encoding="utf-8") as f:
                WORKOUT_CATALOG = json.load(f)
                catalog = list(WORKOUT_CATALOG)
        except Exception as e:
            print(f"WORKOUT CATALOG ERROR: {e}")
            WORKOUT_CATALOG = []
            catalog = []
    
    # Merge custom user workouts if requested
    if user_id:
        try:
            doc_id = _clean_id(user_id)
            custom_docs = db.collection("users").document(doc_id).collection("custom_workouts").get()
            for doc in custom_docs:
                catalog.append(doc.to_dict())
        except Exception as e:
            print(f"Error loading custom workouts for {user_id}: {e}")
            
    return catalog

def _safe_float(val):
    try:
        return float(val)
    except Exception:
        return None

def _normalize(value, low, high):
    if value is None:
        return 0
    if value <= low:
        return 0
    if value >= high:
        return 1
    return (value - low) / (high - low)

def _latest_wellness_entry(rows):
    if not rows:
        return None
    try:
        rows_sorted = sorted(rows, key=lambda r: str(r.get("id", "")))
    except Exception:
        rows_sorted = rows
    return rows_sorted[-1] if rows_sorted else None

def _pick_hrv(entry):
    for key in ["hrv_consistent", "hrv", "hrv_sdnn", "rmssd"]:
        val = entry.get(key)
        if val not in [None, "N/A"]:
            return _safe_float(val)
    return None

def _median(values):
    clean = sorted([v for v in values if v is not None])
    if not clean:
        return None
    mid = len(clean) // 2
    if len(clean) % 2 == 1:
        return clean[mid]
    return (clean[mid - 1] + clean[mid]) / 2

def _pick_sleep_hr_metrics(entry):
    hr_avg = None
    hr_max = None
    for key in ["sleepHrAvg", "sleepHRAvg", "sleep_hr_avg", "sleep_hr_avg_bpm"]:
        if entry.get(key) not in [None, "N/A"]:
            hr_avg = _safe_float(entry.get(key))
            break
    for key in ["sleepHrMax", "sleepHRMax", "sleep_hr_max", "sleep_hr_max_bpm"]:
        if entry.get(key) not in [None, "N/A"]:
            hr_max = _safe_float(entry.get(key))
            break
    peaks = entry.get("sleep_hr_peaks") or entry.get("sleepHrPeaks") or entry.get("sleepHRPeaks")
    if isinstance(peaks, list):
        peaks = [p for p in peaks if isinstance(p, (int, float))]
    else:
        peaks = None
    return hr_avg, hr_max, peaks

def _build_ptsd_analysis(rows):
    entry = _latest_wellness_entry(rows)
    if not entry:
        return None

    hrv = _pick_hrv(entry)
    hrv_history = []
    for row in rows:
        h = _pick_hrv(row)
        if h is not None:
            hrv_history.append(h)
    hrv_baseline = _median(hrv_history)
    hrv_personal_threshold = round((hrv_baseline or 40) * 0.85, 1)
    rhr = _safe_float(entry.get("restingHR") or entry.get("resting_hr"))
    sleep_secs = _safe_float(entry.get("sleepSecs"))
    sleep_hours = round((sleep_secs or 0) / 3600, 1) if sleep_secs else None
    stress = _safe_float(entry.get("stressScore") or entry.get("stress"))
    sleep_hr_avg, sleep_hr_max, sleep_hr_peaks = _pick_sleep_hr_metrics(entry)

    mood = _safe_float(entry.get("survey_0"))
    energy = _safe_float(entry.get("survey_1"))
    sleep_survey = _safe_float(entry.get("survey_2"))
    weather = _safe_float(entry.get("survey_3"))

    # Build state score from latest data
    state_scores = compute_state_scores({
        "hrv": hrv,
        "resting_hr": rhr,
        "sleep": sleep_hours,
        "stress": stress,
        "survey_context": {
            "avg_mood": mood,
            "avg_energy": energy,
            "avg_weather": weather
        }
    })
    state_key = max(state_scores, key=state_scores.get) if state_scores else "balanced"
    state_score = state_scores.get(state_key) if state_scores else 0

    def hrv_status(val):
        if val is None:
            return "××™×Ÿ × ×ª×•×Ÿ HRV ×–××™×Ÿ."
        if hrv_personal_threshold and val < hrv_personal_threshold:
            return "HRV ××ª×—×ª ×œ×¡×£ ×”××™×©×™ â€” ×¡×™××Ÿ ×œ×¢×•××¡ ××• ×“×¨×™×›×•×ª."
        if val < 35:
            return "HRV × ××•×š ×™×—×¡×™×ª â€” ×¡×™××Ÿ ×œ×¢×•××¡ ××• ×“×¨×™×›×•×ª."
        if val < 60:
            return "HRV ×‘×™× ×•× ×™ â€” ×”×ª××•×©×©×•×ª ×¡×‘×™×¨×”."
        return "HRV ×’×‘×•×” â€” ××¢×¨×›×ª ×¨×’×•×¢×” ×•×”×ª××•×©×©×•×ª ×˜×•×‘×”."

    def rhr_status(val):
        if val is None:
            return "××™×Ÿ × ×ª×•×Ÿ ×“×•×¤×§ ×× ×•×—×”."
        if val >= 75:
            return "×“×•×¤×§ ×× ×•×—×” ×’×‘×•×” â€” ×™×™×ª×›×Ÿ ×¡×˜×¨×¡ ××ª××©×š."
        if val <= 55:
            return "×“×•×¤×§ ×× ×•×—×” × ××•×š â€” ×™×™×ª×›×Ÿ ×¢×™×™×¤×•×ª ×¢××•×§×” ××• ×§×™×¤××•×Ÿ."
        return "×“×•×¤×§ ×× ×•×—×” ×‘×˜×•×•×— ×ª×§×™×Ÿ."

    def sleep_status(val):
        if val is None:
            return "××™×Ÿ × ×ª×•×Ÿ ×©×™× ×”."
        if val < 5:
            return "×©×™× ×” ×§×¦×¨×” ×××•×“ â€” ×”×’×•×£ ×‘××“×•×."
        if val < 7:
            return "×©×™× ×” ×‘×™× ×•× ×™×ª â€” ×›×“××™ ×œ×”×©×œ×™× ×”×ª××•×©×©×•×ª."
        return "×©×™× ×” ×˜×•×‘×” â€” ×‘×¡×™×¡ ×™×¦×™×‘ ×œ××¢×¨×›×ª ×”×¢×¦×‘×™×."

    def nightmare_note():
        if sleep_hr_avg is None or sleep_hr_max is None:
            return "××™×Ÿ × ×ª×•× ×™ ×“×•×¤×§ ×ª×•×š ×›×“×™ ×©×™× ×” ×œ×–×™×”×•×™ ×¡×™×•×˜×™×."
        delta = sleep_hr_max - sleep_hr_avg
        if sleep_hr_peaks and len(sleep_hr_peaks) >= 2:
            return "×–×•×”×• ×¤×™×§×™× ×—×•×–×¨×™× ×‘×“×•×¤×§ ×‘×œ×™×œ×” â€” ×—×©×“ ×œ×¡×™×•×˜×™×/×”×¦×¤×” ×¨×’×©×™×ª."
        if delta >= 18:
            return "×§×¤×™×¦×” ×—×“×” ×‘×“×•×¤×§ ×‘×œ×™×œ×” â€” ×—×©×“ ×œ×¡×™×•×˜ ××• ×”×¦×¤×” ×¨×’×©×™×ª."
        if delta >= 12:
            return "×§×¤×™×¦×” ××ª×•× ×” ×‘×“×•×¤×§ ×‘×œ×™×œ×” â€” ×™×™×ª×›×Ÿ ×—×œ×•× ×˜×¢×•×Ÿ."
        return "××™×Ÿ ××™× ×“×™×§×¦×™×” ×‘×¨×•×¨×” ×œ×§×¤×™×¦×•×ª ×“×•×¤×§ ×—×¨×™×’×•×ª ×‘×œ×™×œ×”."

    def state_label(key, score):
        if score is None or score < 0.25:
            return "×××•×–×Ÿ"
        return {
            "fight_flight": "×“×¨×™×›×•×ª (Fight/Flight)",
            "freeze": "×§×™×¤××•×Ÿ (Freeze)",
            "collapse": "×§×¨×™×¡×” (Collapse)"
        }.get(key, "×××•×–×Ÿ")

    def survey_summary():
        parts = []
        if mood is not None:
            parts.append(f"××¦×‘ ×¨×•×—: {int(mood)}/5")
        if energy is not None:
            parts.append(f"×× ×¨×’×™×”: {int(energy)}/5")
        if weather is not None:
            parts.append(f"××–×’ ×¤× ×™××™: {int(weather)}/5")
        if sleep_survey is not None:
            parts.append(f"××™×›×•×ª ×©×™× ×” ×¡×•×‘×™×™×§×˜×™×‘×™×ª: {int(sleep_survey)}/5")
        return " â€¢ ".join(parts) if parts else "××™×Ÿ × ×ª×•× ×™ ×©××œ×•×Ÿ ×–××™× ×™×."

    sleep_match_note = ""
    if sleep_survey is not None and sleep_hours is not None:
        if sleep_hours < 6 and sleep_survey >= 4:
            sleep_match_note = "×™×© ×¤×¢×¨: ×”×©×™× ×” ×§×¦×¨×” ××‘×œ ×”×ª×—×•×©×” ×˜×•×‘×” â€” ×™×™×ª×›×Ÿ ×× ×’× ×•×Ÿ ×“×¨×™×›×•×ª."
        elif sleep_hours >= 7 and sleep_survey <= 2:
            sleep_match_note = "×™×© ×¤×¢×¨: ×”×©×™× ×” ××¨×•×›×” ××‘×œ ×”×ª×—×•×©×” ×¢×™×™×¤×” â€” ×™×™×ª×›×Ÿ ×©×™× ×” ×œ× ××©×§××ª."

    summary_parts = [hrv_status(hrv), rhr_status(rhr), sleep_status(sleep_hours)]
    if sleep_match_note:
        summary_parts.append(sleep_match_note)
    nightmare_summary = nightmare_note()
    if nightmare_summary:
        summary_parts.append(nightmare_summary)

    return {
        "latest_date": entry.get("id"),
        "metrics": {
            "hrv": hrv,
            "resting_hr": rhr,
            "sleep_hours": sleep_hours
        },
        "thresholds": {
            "hrv_baseline": hrv_baseline,
            "hrv_personal_threshold": hrv_personal_threshold
        },
        "surveys": {
            "mood": mood,
            "energy": energy,
            "sleep_quality": sleep_survey,
            "weather": weather
        },
        "state": {
            "key": state_key,
            "label": state_label(state_key, state_score),
            "score": round(state_score or 0, 2)
        },
        "notes": {
            "physical": f"{hrv_status(hrv)} {rhr_status(rhr)}",
            "sleep": f"{sleep_status(sleep_hours)} {sleep_match_note}".strip(),
            "questionnaires": survey_summary(),
            "nightmares": nightmare_summary,
            "hrv_threshold": f"×¡×£ HRV ××™×©×™: {hrv_personal_threshold} (×‘×¡×™×¡ {round(hrv_baseline,1) if hrv_baseline else '×œ× ×–××™×Ÿ'})",
            "summary": " ".join([p for p in summary_parts if p])
        }
    }

def compute_state_scores(data, user_id=None, audio_bytes=None):
    """Returns balanced 3F scores (fight_flight, freeze, collapse)."""
    survey = data.get("survey_context", {}) or {}
    mood = _safe_float(survey.get("avg_mood"))
    energy = _safe_float(survey.get("avg_energy"))
    weather = _safe_float(survey.get("avg_weather"))

    # Survey-based signals (1-5)
    mood_low = _normalize(5 - (mood or 3), 1, 4) if mood is not None else 0
    energy_low = _normalize(5 - (energy or 3), 1, 4) if energy is not None else 0
    weather_low = _normalize(5 - (weather or 3), 1, 4) if weather is not None else 0

    # Physiology-based signals
    hrv = _safe_float(data.get("hrv"))
    rhr = _safe_float(data.get("resting_hr"))
    stress = _safe_float(data.get("stress"))
    sleep = _safe_float(data.get("sleep"))
    body_battery = _safe_float(data.get("body_battery"))

    hrv_low = _normalize((40 - hrv) if hrv is not None else None, 5, 25) if hrv is not None else 0
    rhr_high = _normalize(rhr, 65, 85) if rhr is not None else 0
    stress_high = _normalize(stress, 50, 80) if stress is not None else 0
    sleep_low = _normalize((6 - sleep) if sleep is not None else None, 0.5, 3) if sleep is not None else 0
    rhr_low = _normalize((65 - rhr) if rhr is not None else None, 0, 15) if rhr is not None else 0
    bb_low = _normalize((30 - (body_battery or 50)), 0, 20) if body_battery is not None else 0

    # 1. Voice AI Analysis
    voice_state = analyze_voice_tone(audio_bytes)
    voice_weight = 0.4 if voice_state else 0

    # 2. Garmin Biometrics Logic
    # Fight/Flight: High HR, Low HRV, High Stress
    fight_flight_phys = (hrv_low + rhr_high + stress_high) / 3
    # Collapse: Very low Body Battery
    collapse_phys = bb_low
    # Freeze: Sleep low, HRV low, RHR low
    freeze_phys = (sleep_low + hrv_low + rhr_low) / 3

    # 3. Healthcare API (FHIR Store)
    last_state = get_last_fhir_state(user_id) if user_id else None
    fhir_weight = 0.2 if last_state else 0

    # Combining scores
    ff_score = (fight_flight_phys + (1 if voice_state == "fight_flight" else 0) * voice_weight + (1 if last_state == "fight_flight" else 0) * fhir_weight)
    fr_score = (freeze_phys + (1 if voice_state == "freeze" else 0) * voice_weight + (1 if last_state == "freeze" else 0) * fhir_weight)
    co_score = (collapse_phys + (1 if voice_state == "collapse" else 0) * voice_weight + (1 if last_state == "collapse" else 0) * fhir_weight)

    total_ff = round(ff_score / (1 + voice_weight + fhir_weight), 3)
    total_fr = round(fr_score / (1 + voice_weight + fhir_weight), 3)
    total_co = round(co_score / (1 + voice_weight + fhir_weight), 3)

    return {
        "fight_flight": total_ff,
        "freeze": total_fr,
        "collapse": total_co
    }

def recommend_workouts(data, user_id=None, audio_bytes=None, max_count=WORKOUT_RECOMMENDATION_COUNT):
    catalog = load_workout_catalog(user_id=user_id)
    
    # Filter by user preferences if available
    user_doc = get_user_doc(user_id) if user_id else {}
    excluded_ids = (user_doc or {}).get("site_settings", {}).get("excluded_workouts", [])
    if excluded_ids:
        catalog = [w for w in catalog if w.get("id") not in excluded_ids]

    scores = compute_state_scores(data, user_id=user_id, audio_bytes=audio_bytes)
    target_state = max(scores, key=scores.get)
    matched = [w for w in catalog if w.get("nervous_system_state") == target_state]
    if len(matched) < max_count:
        others = [w for w in catalog if w.get("nervous_system_state") != target_state]
        matched.extend(others)
    return matched[:max_count], target_state

def get_state_label(state_key):
    labels = {
        "fight_flight": "Fight/Flight",
        "freeze": "Freeze",
        "collapse": "Collapse"
    }
    return labels.get(state_key, "Balanced")

def get_workout_menu(recommended, all_workouts, state_key):
    def to_rows(items, limit=10):
        rows = []
        for w in items[:limit]:
            rows.append({
                "id": f"workout_{w.get('id')}",
                "title": (w.get("name") or "")[:24],
                "description": (w.get("short_description") or "")[:72]
            })
        return rows

    max_total = 10
    recommended_ids = {w.get("id") for w in recommended}
    remaining = [w for w in all_workouts if w.get("id") not in recommended_ids]

    rec_rows = to_rows(recommended, limit=max_total)
    remaining_slots = max_total - len(rec_rows)
    other_rows = to_rows(remaining, limit=remaining_slots) if remaining_slots > 0 else []

    sections = []
    if rec_rows:
        sections.append({
            "title": "××™××•× ×™× ××•××œ×¦×™×",
            "rows": rec_rows
        })
    if other_rows:
        sections.append({
            "title": "×›×œ ×”××™××•× ×™×",
            "rows": other_rows
        })

    return {
        "type": "list",
        "header": {"type": "text", "text": "×”×ª×××ª ××™××•×Ÿ ××™×©×™×ª ğŸ§ "},
        "body": {"text": f"×”××™××•× ×™× ××•×ª×××™× ×œ×¤×™ ××¦×‘ ××¢×¨×›×ª ×”×¢×¦×‘×™× ({get_state_label(state_key)}) ×•×’× ×œ×¤×™ ×”××“×“×™× ×•×”×“×™×•×•×— ×”×¢×¦××™. ×‘×—×¨/×™ ××—×“:"},
        "footer": {"text": "Deep-Rest Guard"},
        "action": {
            "button": "×‘×—×¨ ××™××•×Ÿ",
            "sections": sections
        }
    }

def get_workout_by_id(workout_id):
    catalog = load_workout_catalog()
    return next((w for w in catalog if w.get("id") == workout_id), None)

def build_workout_reason_message(data, state_key, workout):
    survey = data.get("survey_context", {}) or {}
    mood = survey.get("avg_mood")
    energy = survey.get("avg_energy")
    weather = survey.get("avg_weather")
    hrv = data.get("hrv")
    sleep = data.get("sleep")
    rhr = data.get("resting_hr")

    state_label = "Fight/Flight" if state_key == "fight_flight" else "Freeze"
    workout_name = workout.get("name", "×”××™××•×Ÿ")

    signals = []
    if mood not in [None, "N/A"]:
        signals.append(f"××¦×‘ ×¨×•×— {mood}/5")
    if energy not in [None, "N/A"]:
        signals.append(f"×× ×¨×’×™×” {energy}/5")
    if weather not in [None, "N/A"]:
        signals.append(f"××–×’ ×¤× ×™××™ {weather}/5")
    if hrv not in [None, "N/A"]:
        signals.append(f"HRV {hrv}")
    if sleep not in [None, "N/A"]:
        signals.append(f"×©×™× ×” {sleep} ×©×¢×•×ª")
    if rhr not in [None, "N/A"]:
        signals.append(f"×“×•×¤×§ ×× ×•×—×” {rhr}")

    signals_text = " Â· ".join(signals[:4]) if signals else "×”××“×“×™× ×©×œ×š ×”×‘×•×§×¨"
    return (
        f"×‘×•×§×¨ ×˜×•×‘ ğŸ¤ ×œ×¤×™ {signals_text} ×•×”×“×™×•×•×— ×”×¢×¦××™ ×©×œ×š, × ×¨××” ×©×”××¢×¨×›×ª ×©×œ×š × ××¦××ª ×™×•×ª×¨ ×‘××¦×‘ {state_label}. "
        f"×œ×›×Ÿ ×‘×—×¨×ª×™ ×¢×‘×•×¨×š ××ª '{workout_name}' â€” ××™××•×Ÿ ×©×ª×•××š ×‘×•×•×™×¡×•×ª ×¢×“×™×Ÿ ×•××“×•×™×§ ×œ××¦×‘ ×”×–×”. "
        "××¤×©×¨ ×œ×‘×—×•×¨ ×’× ××™××•×Ÿ ××¡×•×’ ××—×¨ ××”×¨×©×™××”, ×•×× ××©×”×• ×œ× ××¨×’×™×© × ×›×•×Ÿ ××¤×©×¨ ×œ×¢×¦×•×¨ ××• ×œ×”×—×œ×™×£."
    )

def format_workout_description(text):
    if not text:
        return ""
    # Normalize numbered steps to bullet points
    lines = []
    for raw_line in text.splitlines():
        line = raw_line.strip()
        if re.match(r"^\d+\)", line):
            line = re.sub(r"^\d+\)\s*", "â€¢ ", line)
        lines.append(line)
    return "\n".join(lines).strip()

def build_workout_audio_script(workout, user_doc):
    """Builds a guided SSML script for workout audio."""
    if not workout:
        return ""
    is_female = (user_doc or {}).get("gender") == "female"
    name = workout.get("name", "×”××™××•×Ÿ")
    goal = workout.get("short_description") or "×•×•×™×¡×•×ª ×¢×“×™×Ÿ ×©×œ ×”××¢×¨×›×ª"
    state = workout.get("nervous_system_state", "")
    state_label = "Fight/Flight" if state == "fight_flight" else "Freeze" if state == "freeze" else "××™×–×•×Ÿ"

    intro = (
        "×”×™×™. " if not is_female else "×”×™×™. "
    )
    intro += (
        f"×‘×•× × ×ª×—×™×œ ×™×—×“ ××ª ×”××™××•×Ÿ {name}. "
        if not is_female else f"×‘×•××™ × ×ª×—×™×œ ×™×—×“ ××ª ×”××™××•×Ÿ {name}. "
    )
    intro += f"×”××˜×¨×” ×©×œ×• ×”×™× {goal}. "
    intro += f"××¦×‘ ××¢×¨×›×ª ×”×¢×¦×‘×™× ×©×œ×š ×›×¢×ª: {state_label}. "

    prep = (
        "×œ×¤× ×™ ×©××ª×—×™×œ×™×, ×“××’ ×œ××™× ×•×œ××¨×—×‘ × ×•×—. "
        if not is_female else "×œ×¤× ×™ ×©××ª×—×™×œ×™×, ×“××’×™ ×œ××™× ×•×œ××¨×—×‘ × ×•×—. "
    )
    prep += (
        "×× ×¦×¨×™×š, ××¤×©×¨ ×œ×”×›×™×Ÿ ×›×™×¡× ××• ××–×¨×Ÿ. "
    )

    tips = (
        "×˜×™×¤ ×œ××¢×¨×›×ª ×”×¢×¦×‘×™×: ×× ××©×”×• ××¨×’×™×© ×œ× × ×¢×™× ××• ×—×–×§ ××“×™, ×¢×¦×•×¨ ××™×“ ×•× ××˜ ××ª ×”×§×¦×‘. "
        if not is_female else "×˜×™×¤ ×œ××¢×¨×›×ª ×”×¢×¦×‘×™×: ×× ××©×”×• ××¨×’×™×© ×œ× × ×¢×™× ××• ×—×–×§ ××“×™, ×¢×¦×¨×™ ××™×“ ×•× ××˜ ××ª ×”×§×¦×‘. "
    )

    steps_text = format_workout_description(workout.get("full_description", ""))
    steps_lines = [l for l in steps_text.splitlines() if l.strip()]
    steps_ssml = ""
    for line in steps_lines:
        clean = re.sub(r"^[â€¢\-]\s*", "", line.strip())
        steps_ssml += f"<break time=\"500ms\"/> {clean} "

    closing = (
        "×¡×™×™×× ×•. ×§×— ×¨×’×¢ ×œ× ×©×™××” ×¨×’×•×¢×”. "
        if not is_female else "×¡×™×™×× ×•. ×§×—×™ ×¨×’×¢ ×œ× ×©×™××” ×¨×’×•×¢×”. "
    )
    closing += "×× ×ª×¨×¦×”, ××¤×©×¨ ×œ×©×ª×£ ××™×š ×”×™×”."

    return (
        "<speak>"
        f"{intro} <break time=\"600ms\"/>"
        f"{prep} <break time=\"700ms\"/>"
        f"{tips} <break time=\"600ms\"/>"
        f"{steps_ssml} <break time=\"800ms\"/>"
        f"{closing}"
        "</speak>"
    )

def generate_workout_script_with_gemini(workout, user_doc):
    """Generates a personalized, high-quality SSML training script with Gemini."""
    if not USE_GEMINI_WORKOUT_SCRIPT or not workout:
        return ""
    
    name = workout.get("name", "×”××™××•×Ÿ")
    goal = workout.get("short_description") or "×•×•×™×¡×•×ª ×¢×“×™×Ÿ ×©×œ ×”××¢×¨×›×ª"
    full_text = format_workout_description(workout.get("full_description", ""))
    gender = (user_doc or {}).get("gender", "male")
    user_name = (user_doc or {}).get("name", "×—×‘×¨")
    state_key = workout.get("nervous_system_state", "balanced")
    state_label = get_state_label(state_key)
    
    prompt = (
        "××ª×” ××××Ÿ ×›×•×©×¨ ××•××—×” ×œ×•×•×™×¡×•×ª ×¨×’×©×™ ×•××¢×¨×›×ª ×”×¢×¦×‘×™×. "
        "×ª×¤×§×™×“×š ×œ×”×¤×•×š ×˜×§×¡×˜ ×©×œ ××™××•×Ÿ ×œ×ª×¡×¨×™×˜ ×”×“×¨×›×” ×§×•×œ×™ ×—×™ ×•××¢×•×“×“ ×‘×¢×‘×¨×™×ª ×‘×¤×•×¨××˜ SSML. "
        "××‘× ×” ×”×ª×¡×¨×™×˜ ×—×™×™×‘ ×œ×›×œ×•×œ:\n"
        "1. ×¤×ª×™×— ××™×©×™: ×¤× ×” ×œ××©×ª××© ×‘×©××• (" + user_name + "), ×”×¦×’ ××ª ×”××™××•×Ÿ (" + name + ") ×•×”××˜×¨×” (" + goal + "). "
        "×”×¡×‘×¨ ×‘×§×¦×¨×” ××™×š ×–×” ×™×¢×–×•×¨ ×œ××¢×¨×›×ª ×”×¢×¦×‘×™× ×©×œ×• (×‘××¦×‘ " + state_label + ").\n"
        "2. ×”×›× ×•×ª: ××” ×¦×¨×™×š ×œ×”×›×™×Ÿ (××™×, ×›×™×¡×, ×‘×’×“×™× × ×•×—×™×).\n"
        "3. ×’×•×£ ×”××™××•×Ÿ: ×”×“×¨×›×” ×¦×¢×“-××—×¨-×¦×¢×“. ×œ×›×œ ×ª×¨×’×™×œ, ×ª×Ÿ ×”× ×—×™×” ×‘×¨×•×¨×”, ×•××– ×”×•×¡×£ ×ª×’×™×ª <break time=\"2000ms\"/> ×›×“×™ ×œ×ª×ª ×–××Ÿ ×œ×”×ª××¨×’×Ÿ. "
        "×× ×”×ª×¨×’×™×œ ×“×•×¨×© ×–××Ÿ ×‘×™×¦×•×¢ (×œ××©×œ 30 ×©× ×™×•×ª), ×”×•×¡×£ <break time=\"5000ms\"/> (××• ×›××” ×ª×’×™×•×ª ×›××œ×•) ×›×“×™ ×œ×ª×ª ×œ××©×ª××© ×–××Ÿ ×œ×‘×¦×¢ ×ª×•×š ×›×“×™ ×”×”×§×œ×˜×”.\n"
        "4. ×˜×™×¤ ×œ××¢×¨×›×ª ×”×¢×¦×‘×™×: ×‘×ª×•×š ×”×”×“×¨×›×”, ×©×œ×‘ ×˜×™×¤ ×¢×œ × ×©×™××” ××• ×¨×™×›×•×– ×©××ª××™× ×œ××¦×‘ ×”× ×•×›×—×™.\n"
        "5. ×¡×™×•× ××¢×•×“×“.\n\n"
        "×“×’×©×™×:\n"
        "- ×”×©×ª××© ×‘××’×“×¨ " + gender + " ×‘×œ×‘×“ (×œ×œ× ×›×ª×™×‘×” ×›×¤×•×œ×”).\n"
        "- ×”×˜×•×Ÿ ×—×, ×× ×•×©×™ ×•××§×¦×•×¢×™.\n"
        "- ×”×©×ª××© ×‘×ª×’×™×•×ª <break/> ×•-<emphasis> ×œ×©×™×¤×•×¨ ×”××™×›×•×ª.\n"
        f"×”× ×—×™×•×ª ×”××™××•×Ÿ ×”××§×•×¨×™×•×ª:\n{full_text}\n\n"
        "×”×—×–×¨ ××ª ×”×ª×¡×¨×™×˜ ×¢×˜×•×£ ×‘-<speak> ×‘×œ×‘×“."
    )
    
    try:
        response = gemini_generate(prompt)
        text = (response.text or "").strip()
        # Ensure it's valid SSML
        if "<speak>" in text:
            start = text.find("<speak>")
            end = text.find("</speak>") + 8
            return text[start:end]
    except Exception as e:
        print(f"GEMINI SCRIPT ERROR: {e}")
    return ""

def request_route_start(sender, workout):
    route_mode = workout.get("route_mode")
    target_minutes = workout.get("target_minutes") or workout.get("duration_minutes")
    target_km = workout.get("target_km")
    db.collection("users").document(_clean_id(sender)).set({
        "pending_route": {
            "workout_id": workout.get("id"),
            "route_mode": route_mode,
            "target_minutes": target_minutes,
            "target_km": target_km
        }
    }, merge=True)
    send_wa(sender, "×›×“×™ ×œ×‘× ×•×ª ×œ×š ××¡×œ×•×œ, ×©×œ×—/×™ ××™×§×•× ×—×™ ××• ×›×ª×•×‘×ª ×”×ª×—×œ×” (×˜×§×¡×˜).")

def send_workout_details(to, workout):
    if not workout:
        send_wa(to, "×œ× ××¦××ª×™ ××ª ×”××™××•×Ÿ ×©×‘×—×¨×ª. × ×¡×”/×™ ×©×•×‘ ×‘×¢×•×“ ×¨×’×¢. âœ¨")
        return
    user_doc = get_user_doc(to)
    name = workout.get("name", "×”××™××•×Ÿ ×©×‘×—×¨×ª")
    user_name = user_doc.get("name", "×—×‘×¨")
    duration = workout.get("duration_minutes")
    intensity = workout.get("intensity", "")
    intro = f"ğŸ‹ï¸ *×”×™×™ {user_name}, ×”× ×” ×”××™××•×Ÿ ×©×œ×š: {name}*"
    if duration:
        intro += f" ({duration} ×“×§×•×ª)"
    if intensity:
        intro += f" Â· {intensity}"

    warning = t_by_gender(
        user_doc,
        "âœ¨ ×× ××©×”×• ××¨×’×™×© ×œ× × ×›×•×Ÿ ××• ×œ× ×‘×˜×•×—, ×¢×¦×•×¨ ××™×“ ×•×‘×—×¨ ××™××•×Ÿ ××—×¨.",
        "âœ¨ ×× ××©×”×• ××¨×’×™×© ×œ× × ×›×•×Ÿ ××• ×œ× ×‘×˜×•×—, ×¢×¦×¨×™ ××™×“ ×•×‘×—×¨×™ ××™××•×Ÿ ××—×¨."
    )
    full_text = format_workout_description(workout.get("full_description", ""))
    # Optional visual aids
    if NERVES_LADDER_IMAGE_URL:
        send_wa_image_url(to, NERVES_LADDER_IMAGE_URL, caption="×¡×•×œ× ××¦×‘×™ ××¢×¨×›×ª ×”×¢×¦×‘×™×")
    media_url = workout.get("media_url") or workout.get("gif_url")
    if media_url:
        send_wa_image_url(to, media_url, caption=f"×“×•×’××” ×œ×ª×¨×’×™×œ: {name}")
    video_url = workout.get("video_url")
    if video_url:
        send_wa_video_url(to, video_url, caption=f"×¡×¨×˜×•×Ÿ: {name}")

    script = generate_workout_script_with_gemini(workout, user_doc)
    if not script:
        script = build_workout_audio_script(workout, user_doc)
    send_tts_reply(to, script, file_prefix="workout")
    send_wa(to, f"{intro}\n\n{full_text}\n\n{warning}")

    set_workout_active(to, workout.get("id"))

    if workout.get("route_required"):
        request_route_start(to, workout)

def clear_pending_route(sender):
    db.collection("users").document(_clean_id(sender)).set({
        "pending_route": firestore.DELETE_FIELD
    }, merge=True)

def handle_pending_route_with_origin(sender, origin_lat, origin_lng, origin_label=""):
    user_doc = get_user_doc(sender)
    pending = user_doc.get("pending_route")
    if not pending:
        return False
    workout = get_workout_by_id(pending.get("workout_id"))
    if not workout:
        send_wa(sender, "×œ× ××¦××ª×™ ××ª ×”××™××•×Ÿ ×›×“×™ ×œ×‘× ×•×ª ××¡×œ×•×œ. × ×¡×”/×™ ×©×•×‘ ×‘×‘×§×©×”.")
        clear_pending_route(sender)
        return True
    route_mode = pending.get("route_mode") or "walk"
    target_minutes = pending.get("target_minutes")
    target_km = pending.get("target_km")
    route_km = estimate_target_km(route_mode, target_minutes, target_km)
    dest_lat, dest_lng = compute_destination(origin_lat, origin_lng, route_km)
    if dest_lat is None or dest_lng is None:
        send_wa(sender, "×œ× ×”×¦×œ×—×ª×™ ×œ×—×©×‘ ×™×¢×“ ×œ××¡×œ×•×œ. × ×¡×”/×™ ×©×•×‘ ×‘×‘×§×©×”.")
        clear_pending_route(sender)
        return True
    origin = (origin_lat, origin_lng)
    destination = (dest_lat, dest_lng)
    waypoint = destination
    # Prefer loop route: start -> waypoint -> back to start
    _ = build_directions(origin, destination, route_mode, loop_back=True, waypoint=waypoint)
    link = build_route_link(origin, destination, route_mode, waypoint=waypoint, loop_back=True)
    send_wa_location(sender, origin_lat, origin_lng, name="× ×§×•×“×ª ×”×ª×—×œ×”", address=origin_label or "")
    send_wa(sender, f"×”× ×” ××¡×œ×•×œ ××•××œ×¥ ×‘×”×ª×× ×œ××™××•×Ÿ ×©×‘×—×¨×ª:\n{link}")
    clear_pending_route(sender)
    return True

def maybe_request_limitations(sender, user_doc):
    if user_doc.get("limitations_profiled"):
        return False
    if not user_doc.get("limitations_pending"):
        prompt = (
            "×œ×¤× ×™ ×©× ×ª××™× ××™××•×Ÿ, ×—×©×•×‘ ×œ×™ ×œ×“×¢×ª ×× ×™×© ××’×‘×œ×•×ª ×’×•×¤× ×™×•×ª ××• ×¨×’×™×©×•×™×•×ª. "
            "×›×ª×•×‘/×›×ª×‘×™ ×‘×§×¦×¨×” (×œ××©×œ: \"×›××‘×™ ×›×ª×£\", \"×§×˜×™×¢×”\", \"××™×Ÿ ××’×‘×œ×•×ª\")."
        )
        db.collection("users").document(_clean_id(sender)).set(
            {"limitations_pending": True}, merge=True
        )
        send_wa(sender, prompt)
        return True
    return False

def handle_workout_request(sender, user_doc, audio_bytes=None):
    if maybe_request_limitations(sender, user_doc):
        return
    try:
        intervals_data = fetch_intervals_data(sender)
    except Exception as e:
        print(f"Workout data error: {e}")
        intervals_data = {"user_name": user_doc.get("name", "×—×‘×¨"), "survey_context": {}}
    workouts, state_key = recommend_workouts(intervals_data, user_id=sender, audio_bytes=audio_bytes)
    catalog = load_workout_catalog()
    if not workouts:
        send_wa(sender, "××™×Ÿ ×›×¨×’×¢ ××™××•× ×™× ×–××™× ×™×. × ×¡×”/×™ ×©×•×‘ ×‘×¢×•×“ ×¨×’×¢. âœ¨")
        return
    store_workout_recommendations(sender, workouts, state_key)
    
    # Save the identified state to FHIR as an observation
    try:
        save_nervous_system_state_to_fhir(sender, state_key, intervals_data)
    except Exception as e:
        print(f"FAILED TO SAVE STATE TO FHIR: {e}")

    send_wa(sender, "×”×ª×××ª×™ ×œ×š ××™××•×Ÿ ×œ×¤×™ ×”××“×“×™× ×•×”×“×™×•×•×— ×”×¢×¦××™ ×©×œ×š. ×”× ×” ×”××¤×©×¨×•×™×•×ª:", interactive_list=get_workout_menu(workouts, catalog, state_key))

def save_nervous_system_state_to_fhir(user_id, state_key, data):
    if not _healthcare_enabled():
        return
    patient_id = _fhir_id_from_parts("user", _clean_id(user_id))
    obs = {
        "resourceType": "Observation",
        "status": "final",
        "category": [{
            "coding": [{
                "system": "http://terminology.hl7.org/CodeSystem/observation-category",
                "code": "vital-signs",
                "display": "Vital Signs"
            }]
        }, {
            "coding": [{
                "system": "https://sportruma.app/observation-category",
                "code": "nervous-system",
                "display": "Nervous System"
            }]
        }],
        "code": {
            "coding": [{
                "system": "https://sportruma.app/observation",
                "code": "nervous_system_state",
                "display": "Nervous System State"
            }, {
                "system": "https://sportruma.app/nervous-system-state",
                "code": state_key,
                "display": get_state_label(state_key)
            }]
        },
        "subject": {"reference": f"Patient/{patient_id}"},
        "effectiveDateTime": datetime.datetime.utcnow().isoformat() + "Z",
        "valueString": get_state_label(state_key)
    }
    
    # Add HRV and Stress components if available
    components = []
    _add_component(components, "hrv", "Heart rate variability", data.get("hrv"), unit="ms")
    _add_component(components, "stress_score", "Stress score", data.get("stress"))
    if components:
        obs["component"] = components

    try:
        session = _authorized_healthcare_session()
        res = session.post(_fhir_base_url() + "/Observation", json=obs, timeout=10)
        print(f"Saved nervous system state {state_key} to FHIR: {res.status_code}")
    except Exception as e:
        print(f"Error saving to FHIR: {e}")

def handle_workout_finished(sender, user_doc):
    active_workout_id = user_doc.get("active_workout_id")
    if not active_workout_id:
        send_wa(sender, "×œ× ×¨××™×ª×™ ×©×”×ª×—×œ×ª ××™××•×Ÿ, ××‘×œ ×›×œ ×”×›×‘×•×“ ×¢×œ ×”×ª× ×•×¢×”! âœ¨")
        return
    
    workout = get_workout_by_id(active_workout_id)
    workout_name = workout.get("name") if workout else "××™××•×Ÿ"
    
    # Fetch current data to see impact
    try:
        data = fetch_intervals_data(sender)
        hrv = data.get("hrv")
        
        # Save completion to FHIR
        patient_id = _fhir_id_from_parts("user", _clean_id(sender))
        obs = {
            "resourceType": "Observation",
            "status": "final",
            "code": {
                "coding": [{
                    "system": "https://sportruma.app/observation",
                    "code": "workout_completed",
                    "display": "Workout Completed"
                }]
            },
            "subject": {"reference": f"Patient/{patient_id}"},
            "effectiveDateTime": datetime.datetime.utcnow().isoformat() + "Z",
            "valueString": f"Completed {workout_name}",
            "component": []
        }
        _add_component(obs["component"], "hrv_post", "Heart rate variability (Post-workout)", hrv, unit="ms")
        
        session = _authorized_healthcare_session()
        session.post(_fhir_base_url() + "/Observation", json=obs, timeout=10)
    except Exception as e:
        print(f"ERROR SAVING WORKOUT COMPLETION: {e}")

    # Clear active workout
    db.collection("users").document(_clean_id(sender)).update({
        "active_workout_id": firestore.DELETE_FIELD
    })
    
    send_wa(sender, f"×›×œ ×”×›×‘×•×“ ×¢×œ ×¡×™×•× ×”××™××•×Ÿ '{workout_name}'! ğŸŒŸ ×ª×™×¢×“×ª×™ ××ª ×”××××¥ ×©×œ×š. ××™×š ××ª/×” ××¨×’×™×©/×” ×¢×›×©×™×•?")

def send_wa_image(to, media_id, caption=""):
    """×©×•×œ×—×ª ×ª××•× ×” ×œ××©×ª××© ×œ×¤×™ media_id."""
    to_clean = _clean_id(to)
    headers = {"Authorization": f"Bearer {WA_TOKEN}"}
    payload = {
        "messaging_product": "whatsapp",
        "to": to_clean,
        "type": "image",
        "image": {"id": media_id, "caption": caption}
    }
    try:
        res = requests.post(
            f"https://graph.facebook.com/v21.0/{PHONE_NUMBER_ID}/messages",
            json=payload,
            headers=headers,
            timeout=10
        )
        print(f"Send image status: {res.status_code}")
    except Exception as e:
        print(f"Error sending image: {e}")

def send_wa_image_url(to, image_url, caption=""):
    """×©×•×œ×—×ª ×ª××•× ×” ×œ×¤×™ URL."""
    if not image_url:
        return
    to_clean = _clean_id(to)
    headers = {"Authorization": f"Bearer {WA_TOKEN}"}
    payload = {
        "messaging_product": "whatsapp",
        "to": to_clean,
        "type": "image",
        "image": {"link": image_url, "caption": caption}
    }
    try:
        res = requests.post(
            f"https://graph.facebook.com/v21.0/{PHONE_NUMBER_ID}/messages",
            json=payload,
            headers=headers,
            timeout=10
        )
        print(f"Send image (link) status: {res.status_code}")
    except Exception as e:
        print(f"Error sending image link: {e}")

def send_wa_video_url(to, video_url, caption=""):
    """×©×•×œ×—×ª ×•×™×“××• ×œ×¤×™ URL."""
    if not video_url:
        return
    to_clean = _clean_id(to)
    headers = {"Authorization": f"Bearer {WA_TOKEN}"}
    payload = {
        "messaging_product": "whatsapp",
        "to": to_clean,
        "type": "video",
        "video": {"link": video_url, "caption": caption}
    }
    try:
        res = requests.post(
            f"https://graph.facebook.com/v21.0/{PHONE_NUMBER_ID}/messages",
            json=payload,
            headers=headers,
            timeout=10
        )
        print(f"Send video (link) status: {res.status_code}")
    except Exception as e:
        print(f"Error sending video link: {e}")

def get_graph_menu():
    return {
        "type": "list",
        "header": {"type": "text", "text": "×“×•×— ×”×ª×§×“××•×ª ×•×™×–×•××œ×™ ğŸ“ˆ"},
        "body": {"text": "×‘×—×¨ ××ª ×˜×•×•×— ×”×–××Ÿ ×©×‘×¨×¦×•× ×š ×œ×¨××•×ª ×‘×’×¨×£:"},
        "footer": {"text": "Deep-Rest Guard"},
        "action": {
            "button": "×‘×—×¨ ×˜×•×•×— ×–××Ÿ",
            "sections": [
                {
                    "title": "×˜×•×•×— ×ª×¦×•×’×”",
                    "rows": [
                        {"id": "graph_3", "title": "ğŸ“Š ×’×¨×£ ×™×•××™", "description": "3 ×”×™××™× ×”××—×¨×•× ×™×"},
                        {"id": "graph_7", "title": "ğŸ“ˆ ×’×¨×£ ×©×‘×•×¢×™", "description": "7 ×”×™××™× ×”××—×¨×•× ×™×"},
                        {"id": "graph_30", "title": "ğŸ“… ×’×¨×£ ×—×•×“×©×™", "description": "30 ×”×™××™× ×”××—×¨×•× ×™×"}
                    ]
                }
            ]
        }
    }

def generate_progress_graph(user_id, days=14):
    """××™×™×¦×¨×ª ×’×¨×£ ×”×ª×§×“××•×ª ×•×©×•×œ×—×ª ××•×ª×• ×›×ª××•× ×”."""
    doc_id = _clean_id(user_id)
    user_doc = get_user_doc(user_id)
    user_name = user_doc.get("name", "User")
    
    # Get settings for graph
    graph_settings = user_doc.get("site_settings", {}).get("wa_graph_metrics", ["hrv", "sleep", "energy", "workouts"])
    
    history_docs = db.collection("users").document(doc_id).collection("wellness_history")\
        .order_by("id", direction=firestore.Query.DESCENDING).limit(days).get()
    
    data_list = [d.to_dict() for d in history_docs]
    if not data_list: return None
    
    df = pd.DataFrame(data_list)
    df['date'] = pd.to_datetime(df['id'])
    df = df.sort_values('date')
    
    # Use a cleaner style
    plt.figure(figsize=(10, 6))
    plt.grid(True, linestyle='--', alpha=0.6)
    
    if "hrv" in graph_settings:
        # HRV: Look for any available HRV metric (consistent key first, then fallbacks)
        possible_hrv_cols = ['hrv_consistent', 'hrv', 'hrv_sdnn', 'rmssd']
        df['hrv_plot'] = np.nan
        for col in possible_hrv_cols:
            if col in df.columns:
                df[col] = pd.to_numeric(df[col], errors='coerce')
                df['hrv_plot'] = df['hrv_plot'].fillna(df[col])
        hrv_data = df[df['hrv_plot'] > 0]
        if not hrv_data.empty:
            plt.plot(hrv_data['date'], hrv_data['hrv_plot'], marker='o', label='Recovery (HRV)', color='#2ecc71', linewidth=2.5)

    if "sleep" in graph_settings:
        df['sleep_plot'] = df.get('sleepSecs', pd.Series([0]*len(df))).fillna(0) / 360 
        plt.plot(df['date'], df['sleep_plot'], marker='s', label='Sleep Quality (scaled)', color='#3498db', linewidth=2.5)
    
    if "energy" in graph_settings:
        df['energy_plot'] = pd.to_numeric(df.get('survey_1', pd.Series([np.nan]*len(df))), errors='coerce').fillna(0) * 20
        energy_data = df[df['energy_plot'] > 0]
        if not energy_data.empty:
            plt.plot(energy_data['date'], energy_data['energy_plot'], marker='D', label='Energy Level (1-5)', color='#9b59b6', linewidth=2.5)
    
    if "workouts" in graph_settings:
        raw_workout = pd.to_numeric(df.get('workout_minutes', pd.Series([0]*len(df))), errors='coerce').fillna(0)
        max_workout = raw_workout.max() if not raw_workout.empty else 0
        if max_workout > 120:
            df['workout_plot'] = raw_workout * (120 / max_workout)
            workout_label = 'Workout Minutes (scaled)'
        else:
            df['workout_plot'] = raw_workout
            workout_label = 'Workout Minutes'
        workout_data = df[df['workout_plot'] > 0]
        if not workout_data.empty:
            plt.plot(workout_data['date'], workout_data['workout_plot'], marker='x', label=workout_label, color='#e67e22', linewidth=2)
    
    plt.title('Your Progress Report', fontsize=18, pad=20, fontweight='bold')
    plt.xlabel('Date', fontsize=12, fontweight='bold')
    plt.ylabel('Normalized Scale (0-120)', fontsize=12, fontweight='bold')
    plt.legend(loc='upper left', frameon=True, shadow=True, fontsize=10)
    
    # Better date formatting
    plt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%d/%m'))
    plt.gca().xaxis.set_major_locator(mdates.DayLocator())
    plt.xticks(rotation=45)
    
    # Set Y axis to show a consistent range
    plt.ylim(0, 130) 
    plt.tight_layout()
    
    buf = BytesIO()
    plt.savefig(buf, format='png', dpi=120)
    plt.close()
    return buf.getvalue()

def generate_weekly_report(user_id, force_ai=False):
    doc_id = _clean_id(user_id)
    # Fetch 14 days of history to compare weeks
    history_docs = db.collection("users").document(doc_id).collection("wellness_history")\
        .order_by("id", direction=firestore.Query.DESCENDING).limit(14).get()
    
    history = [d.to_dict() for d in history_docs]
    if len(history) < 3: return None
    
    # Check if it's Sunday or force_ai is true
    from zoneinfo import ZoneInfo
    now_il = datetime.datetime.now(ZoneInfo("Israel"))
    is_sunday = (now_il.weekday() == 6) # Sunday in Python's weekday() is 6 (Mon=0, Sun=6)
    
    if is_sunday or force_ai:
        return generate_ai_deep_weekly_report(user_id, history)
        
    this_week = history[:7]
    last_week = history[7:14] if len(history) >= 7 else []
    
    def avg(lst, key):
        vals = [item.get(key) for item in lst if item.get(key) and isinstance(item.get(key), (int, float))]
        return sum(vals) / len(vals) if vals else None

    hrv_now = avg(this_week, "hrv") or avg(this_week, "hrv_sdnn")
    hrv_prev = avg(last_week, "hrv") or avg(last_week, "hrv_sdnn")
    sleep_now = avg(this_week, "sleepSecs")
    
    # Survey averages (Mood and Energy)
    mood_avg = avg(this_week, "survey_0")
    energy_avg = avg(this_week, "survey_1")

    report = "ğŸ“Š *×¡×™×›×•× ×—×•×¡×Ÿ ×©×‘×•×¢×™* âš“\n\n"
    
    if hrv_now:
        diff = round(((hrv_now - hrv_prev) / hrv_prev * 100)) if (hrv_prev and hrv_prev > 0) else 0
        emoji = "ğŸ“ˆ" if diff >= 0 else "ğŸ“‰"
        report += f"{emoji} *×—×•×¡×Ÿ ×’×•×¤× ×™ (HRV):* {round(hrv_now)} ({diff}% ×©×‘×•×¢ ×©×¢×‘×¨)\n"
    
    if sleep_now:
        report += f"ğŸ˜´ *×××•×¦×¢ ×©×™× ×”:* {round(sleep_now / 3600, 1)} ×©×¢×•×ª\n"
        
    if mood_avg and energy_avg:
        # Calculate a simple "Mental Balance" score out of 100
        mental_score = round(((mood_avg + energy_avg) / 10) * 100)
        report += f"ğŸ§  *××™×–×•×Ÿ ×¨×’×©×™:* {mental_score}/100 (×œ×¤×™ ×”×“×™×•×•×—×™× ×©×œ×š)\n"

    report += "\nğŸ’¡ *×ª×•×‘× ×” ×œ×©×‘×•×¢ ×”×§×¨×•×‘:* "
    if hrv_now and hrv_prev and hrv_now < hrv_prev:
        report += "×”×’×•×£ ×©×œ×š ×ª×—×ª ×¢×•××¡. × ×¡×”/×™ ×œ×ª×¢×“×£ ×©×™× ×” ×•×”×•×¨×“×ª ×¢×¦×™××•×ª. ğŸŒ¿"
    elif mood_avg and mood_avg < 3:
        report += "× ×¨××” ×©×¢×‘×¨ ×¢×œ×™×š ×©×‘×•×¢ ×¨×’×©×™ ×œ× ×¤×©×•×˜. ×× ×—× ×• ×›××Ÿ ×›×“×™ ×œ×”×§×©×™×‘. ğŸ¤"
    else:
        report += "××ª/×” ×‘× ×ª×™×‘ ×”× ×›×•×Ÿ! ×”××¢×¨×›×ª ×©×œ×š ×××•×–× ×ª ×•×—×–×§×”. âœ¨"
        
    return report

def generate_ai_deep_weekly_report(user_id, history, format="whatsapp"):
    """Generates a deep, AI-powered weekly report using Gemini."""
    if not ai_client:
        return "×©×’×™××”: ×©×™×¨×•×ª ×”-AI ×œ× ×–××™×Ÿ ×›×¨×’×¢."
    
    user_doc = get_user_doc(user_id)
    u_name = user_doc.get("name", "×—×‘×¨")
    
    # Fetch calendar events for context
    events = fetch_events_range(user_id, days=7) or []
    events_str = "\n".join([f"- {e.get('summary')} ({e.get('start', {}).get('dateTime') or e.get('start', {}).get('date')})" for e in events])
    
    # Format history for AI
    history_summary = []
    for day in history:
        date = day.get("id")
        hrv = day.get("hrv") or day.get("hrv_sdnn")
        sleep = round((day.get("sleepSecs") or 0) / 3600, 1)
        rhr = day.get("restingHR") or day.get("resting_hr")
        mood = day.get("survey_0")
        energy = day.get("survey_1")
        weather = day.get("survey_3")
        workouts = day.get("active_workout_name") or "××™×Ÿ ××™××•×Ÿ"
        history_summary.append(f"Date: {date}, HRV: {hrv}, Sleep: {sleep}h, RHR: {rhr}, Mood: {mood}, Energy: {energy}, Weather: {weather}, Workout: {workouts}")

    history_text = "\n".join(history_summary)
    
    if format == "whatsapp":
        prompt = f"""
You are Deep-Rest Guard, an AI assistant specializing in nervous system regulation.
Generate a CONCISE weekly summary for {u_name} for WhatsApp.

Data (14 days): {history_text}
Calendar (Next 7 days): {events_str}

Format:
- Start with "ğŸ“Š *×¡×™×›×•× ×©×‘×•×¢×™ ×§×¦×¨ - Deep-Rest Guard* âš“"
- Use 3-5 clear bullet points for insights.
- Include a section "ğŸ“… *×”××œ×¦×•×ª ×œ×©×‘×•×¢ ×”×‘× (××‘×•×¡×¡ ×œ×•"×–):*" with 2-3 specific tips based on their upcoming events.
- Keep it short, readable, and empathetic.
- Use emojis.
- Language: Hebrew.
"""
    else:
        # Detailed format for web
        prompt = f"""
You are Deep-Rest Guard, an AI assistant specializing in nervous system regulation and Polyvagal Theory.
Generate a DEEP, DETAILED weekly report for {u_name} for the web dashboard.

Data (14 days): {history_text}
Calendar (Next 7 days): {events_str}

Content Requirements:
1. Deep analysis of nervous system patterns (Fight/Flight/Freeze/Collapse).
2. Correlation between specific events, workouts, and sleep quality.
3. Detailed breakdown of how exercise impacted HRV.
4. Comprehensive recommendations for the coming week.
5. In-depth explanation of physiological markers.

Tone: Professional, clinical yet empathetic, detailed.
Formatting: Use Markdown, clear headings, and long paragraphs where needed.
Language: Hebrew.
"""

    try:
        response = ai_client.models.generate_content(
            model=GEMINI_MODEL,
            contents=prompt
        )
        report_text = response.text or "×œ× ×”×¦×œ×—×ª×™ ×œ×”×¤×™×§ ××ª ×”×“×•×— ×”×©×‘×•×¢×™."
        
        # Store detailed report in Firestore for the website
        if format == "whatsapp":
            # Proactively generate and store the web version too
            web_report = generate_ai_deep_weekly_report(user_id, history, format="web")
            db.collection("users").document(_clean_id(user_id)).collection("deep_reports").document("latest").set({
                "content": web_report,
                "timestamp": datetime.datetime.now(ZoneInfo("Israel")).isoformat()
            })
            
        return report_text
    except Exception as e:
        print(f"AI WEEKLY REPORT ERROR: {e}")
        return "×©×’×™××” ×‘×”×¤×§×ª ×”×“×•×— ×”×©×‘×•×¢×™."

def get_emergency_list(body_text="×‘×—×¨/×™ ××ª ×”××•×¤×¦×™×” ×”××ª××™××” ×œ×š ×›×¨×’×¢:", emergency_name=None):
    # WhatsApp limits: 
    # 1. Total rows across ALL sections must be <= 10.
    # 2. Row title must be <= 24 chars.
    
    # Section 1: Core Tools (Max 6 rows)
    core_rows = [
        {"id": "action_breath", "title": "ğŸ§˜ × ×©×™××”", "description": "×ª×¨×’×™×œ × ×©×™××” ×œ×”×¨×’×¢×”"},
        {"id": "action_calendar", "title": "ğŸ“… ×™×•××Ÿ", "description": "×”×¦×’×ª ××™×¨×•×¢×™× ××”×™×•××Ÿ"},
        {"id": "action_help_menu", "title": "âš“ ×¢×–×¨×”", "description": "×¤×¨×•×˜×•×§×•×œ ×¡×™×•×¢ ×•××•×§×“×™×"},
        {"id": "action_ground", "title": "âš“ ×§×¨×§×•×¢", "description": "×˜×›× ×™×§×ª 5-4-3-2-1"},
        {"id": "action_workout", "title": "ğŸ’ª ××™××•×Ÿ", "description": "××™××•×Ÿ ××•×ª×× ××™×©×™×ª"}
    ]
    
    if emergency_name:
        # Truncate name to fit 24 char limit (âš“ ×”×•×“×¢×” ×œ + 12 chars = ~24)
        safe_name = str(emergency_name)[:10]
        core_rows.append({"id": "action_help_contact", "title": f"âš“ ×”×•×“×¢×” ×œ{safe_name}", "description": "×©×œ×™×—×ª ×”×•×“×¢×” ×œ×¢×–×¨×”"})
    
    core_rows.append({"id": "action_fine", "title": "âœ… ×”×›×œ ×‘×¡×“×¨", "description": "×× ×™ ××¨×’×™×©/×” ×™×•×ª×¨ ×˜×•×‘"})

    # Section 2: External Help (Remaining slots)
    # We have used up to 7 slots in Section 1. We have 3 slots left for Section 2.
    external_rows = [
        {"id": "help_nefesh", "title": "âš“ ××•×§×“ × ×¤×© ××—×ª", "description": "*8944 - ××©×¨×“ ×”×‘×™×˜×—×•×Ÿ"},
        {"id": "help_natal", "title": "â¤ï¸ ××•×§×“ × ×˜\"×œ", "description": "1-800-363-363"},
        {"id": "help_eran", "title": "ğŸ‘‚ ××•×§×“ ×¢×¨\"×Ÿ", "description": "1201 - ×¢×–×¨×” ×¨××©×•× ×”"}
    ]
    
    # Final check to ensure total rows <= 10
    total_allowed = 10
    current_total = len(core_rows)
    slots_left = total_allowed - current_total
    
    if slots_left < 0:
        # Should not happen with current logic, but for safety:
        core_rows = core_rows[:total_allowed]
        external_rows = []
    else:
        external_rows = external_rows[:slots_left]

    return {
        "type": "list",
        "header": {"type": "text", "text": "×›×œ×™× ×œ×•×•×™×¡×•×ª ×•×¡×™×•×¢ âš“"},
        "body": {"text": (body_text or "×‘×—×¨/×™ ×›×œ×™ ×œ×¡×™×•×¢:")[:1024]},
        "footer": {"text": "Deep-Rest Guard ğŸ¤"},
        "action": {
            "button": "××¤×©×¨×•×™×•×ª ×¡×™×•×¢",
            "sections": [
                {
                    "title": "×›×œ×™× ×œ×•×•×™×¡×•×ª",
                    "rows": core_rows
                },
                {
                    "title": "××•×§×“×™ ×¡×™×•×¢ ×—×™×¦×•× ×™×™×",
                    "rows": external_rows
                }
            ]
        }
    }

def get_community_menu():
    """Returns a menu for community features."""
    return {
        "type": "list",
        "header": {"type": "text", "text": "×”×§×”×™×œ×” ×©×œ× ×• ğŸ¤"},
        "body": {"text": "×›××Ÿ ××¤×©×¨ ×œ×¨××•×ª ××” ×§×•×¨×” ×‘×§×”×™×œ×”, ×œ××¦×•× ×©×•×ª×£/×” ××• ×œ×”×¦×˜×¨×£ ×œ×§×‘×•×¦×”:"},
        "footer": {"text": "Deep-Rest Guard"},
        "action": {
            "button": "×‘×—×¨ ××¤×©×¨×•×ª",
            "sections": [
                {
                    "title": "×”×§×”×™×œ×” ×©×œ×™",
                    "rows": [
                        {"id": "comm_stats", "title": "ğŸ“Š ×›××” ×ª×¨×’×œ× ×• ×”×™×•×?", "description": "×¡×˜×˜×™×¡×˜×™×§×” ×§×‘×•×¦×ª×™×ª ×× ×•× ×™××™×ª"},
                        {"id": "comm_join_group", "title": "ğŸ“¢ ×”×¦×˜×¨×¤×•×ª ×œ×§×‘×•×¦×”", "description": "××¢×‘×¨ ×œ×§×‘×•×¦×ª ×”×§×”×™×œ×” ×‘×•×•××˜×¡××¤"},
                        {"id": "comm_find_partner", "title": "ğŸ¤ ×—×¤×© ×©×•×ª×£/×”", "description": "×—×™×‘×•×¨ ×œ××©×ª××© ××—×¨ ×œ×©×™×—×” ××• ××™××•×Ÿ"},
                        {"id": "comm_opt_out", "title": "ğŸ”• ×”×¤×¡×§×ª ×–××™× ×•×ª", "description": "×”×¡×¨×ª ×”×¤×¨×•×¤×™×œ ××—×™×¤×•×© ×©×•×ª×¤×™×"}
                    ]
                }
            ]
        }
    }

def find_community_partner(sender_id):
    """Finds a random partner who opted-in, excluding the sender."""
    query = db.collection("users").where("partner_opt_in", "==", True).limit(10).get()
    potential_partners = [u for u in query if u.id != _clean_id(sender_id)]
    if not potential_partners: return None
    import random
    return random.choice(potential_partners).to_dict(), random.choice(potential_partners).id

def log_community_action(user_id, action_type):
    """Logs a specific regulation action with a timestamp."""
    db.collection("community_actions").add({
        "user_id": _clean_id(user_id),
        "action": action_type,
        "timestamp": firestore.SERVER_TIMESTAMP
    })

def get_community_message(u_name):
    """Generates a community message based on actions in the last 24 hours."""
    now = datetime.datetime.now(datetime.timezone.utc)
    yesterday = now - datetime.timedelta(hours=24)
    
    # Query actions in the last 24h
    actions_ref = db.collection("community_actions").where("timestamp", ">", yesterday).get()
    actions_count = len(actions_ref)
    
    # Count unique active users in last 24h
    active_users = set()
    for doc in actions_ref:
        active_users.add(doc.to_dict().get("user_id"))
    
    users_count = len(active_users)
    if users_count == 0:
        users_count = len(db.collection("users").get()) # Fallback to total users
        
    minutes = actions_count * 5 # Estimate 5 mins per action
    
    return f"×”×™×™ {u_name}, ××ª/×” ×œ× ×œ×‘×“. ğŸ¤\n\n×‘-24 ×”×©×¢×•×ª ×”××—×¨×•× ×•×ª, ×‘×§×”×™×œ×” ×©×œ× ×• ×”×™×• *{users_count} ×—×‘×¨×™×* ×¤×¢×™×œ×™×. ×™×—×“ ××™×ª×š, × ×¢×©×• *{actions_count} ×ª×¨×’×•×œ×™×*, ×©×”× ×‘×¢×¨×š *{minutes} ×“×§×•×ª* ×©×œ ×©×§×˜. âœ¨\n\n×›×œ ×¤×¢× ×©××ª/×” ××ª×¨×’×œ/×ª, ×–×” ×—×œ×§ ××”××××¥ ×©×œ ×›×•×œ× ×•. ×˜×•×‘ ×©××ª/×” ×›××Ÿ! âš“"

def get_user_doc(user_id):
    return db.collection("users").document(_clean_id(user_id)).get().to_dict() or {}

def set_user_credentials(user_id, api_key, athlete_id, name=None, emergency_name=None, emergency_phone=None, gender=None):
    # × ×™×§×•×™ ×™×¡×•×“×™ - ×œ×•×§×—×™× ×¨×§ ××ª ×”××™×œ×” ×”×¨××©×•× ×” ×•×× ×§×™× ×ª×•×•×™× ×œ× ×¨×¦×•×™×™×
    clean_key = _first_word(api_key)
    clean_id = _first_word(athlete_id)
    doc_id = _clean_id(user_id)
    
    data = {
        "intervals_api_key": clean_key,
        "intervals_athlete_id": clean_id,
        "connected_at": firestore.SERVER_TIMESTAMP
    }
    if name: data["name"] = name.strip()
    if emergency_name: data["emergency_name"] = emergency_name.strip()
    if emergency_phone: data["emergency_phone"] = _clean_id(emergency_phone)
    if gender: data["gender"] = gender
    
    print(f"SAVING CREDENTIALS: user_id={user_id}, athlete_id={clean_id}, gender={gender}")
    db.collection("users").document(doc_id).set(data, merge=True)

def set_user_profile(user_id, name=None, email=None, gender=None, emergency_name=None, emergency_phone=None):
    doc_id = _clean_id(user_id)
    data = {}
    if name:
        data["name"] = name.strip()
    if email:
        data["email"] = email.strip()
    if gender:
        data["gender"] = gender
    if emergency_name:
        data["emergency_name"] = emergency_name.strip()
    if emergency_phone:
        data["emergency_phone"] = _clean_id(emergency_phone)
    if data:
        db.collection("users").document(doc_id).set(data, merge=True)

# --- INTERVALS.ICU LOGIC ---
def fetch_intervals_data(user_id):
    user_doc = get_user_doc(user_id)
    
    api_key = _first_word(user_doc.get("intervals_api_key"))
    athlete_id = _first_word(user_doc.get("intervals_athlete_id"))

    if not api_key or not athlete_id:
        raise Exception("User not connected")

    auth = ('API_KEY', api_key)
    
    today = datetime.date.today()
    oldest = (today - datetime.timedelta(days=14)).isoformat()
    newest = today.isoformat()
    
    wellness_data = []
    try:
        url = f"https://intervals.icu/api/v1/athlete/{athlete_id}/wellness"
        print(f"DEBUG: Fetching wellness from {url} with auth API_KEY:{api_key[:4]} for last 14 days...")
        res = requests.get(url, auth=auth, params={"oldest": oldest, "newest": newest}, timeout=15)
        print(f"DEBUG: Wellness status: {res.status_code}")
        if res.status_code == 200:
            wellness_data = res.json()
            print(f"DEBUG: Received {len(wellness_data)} wellness entries")
        else:
            print(f"DEBUG: Wellness error response: {res.text}")
    except Exception as e:
        print(f"DEBUG: Wellness exception: {e}")

    # × ××¦× ××ª ×”×¨×©×•××” ×”×›×™ ×¢×“×›× ×™×ª ×©×™×© ×‘×” HRV ××• ×“×•×¤×§ ×× ×•×—×”
    wellness = {}
    doc_id = _clean_id(user_id)
    if wellness_data and isinstance(wellness_data, list):
        batch = db.batch()
        for entry in wellness_data:
            entry_id = entry.get("id")
            if entry_id:
                # Normalize HRV key BEFORE saving to history
                hrv_val = entry.get("hrv") or entry.get("hrv_sdnn") or entry.get("rmssd")
                if hrv_val: entry["hrv_consistent"] = hrv_val
                
                # Store in history subcollection
                hist_ref = db.collection("users").document(doc_id).collection("wellness_history").document(str(entry_id))
                batch.set(hist_ref, entry, merge=True)
            
            # Check for latest valid record
            hrv_val = entry.get("hrv_consistent")
            rhr_val = entry.get("restingHR") or entry.get("resting_hr")
            body_battery = entry.get("bodyBattery") or entry.get("body_battery")
            if hrv_val or rhr_val:
                wellness = entry
        batch.commit()
        print(f"DEBUG: Saved {len(wellness_data)} entries to history for {doc_id}")
    
    # Fetch some history for trend analysis
    history_docs = db.collection("users").document(doc_id).collection("wellness_history")\
        .order_by("id", direction=firestore.Query.DESCENDING).limit(10).get()
    history_list = [d.to_dict() for d in history_docs]

    # Aggregate survey data for AI context
    def avg_s(key):
        vals = [h.get(key) for h in history_list if h.get(key)]
        return round(sum(vals)/len(vals), 1) if vals else "N/A"
    
    survey_context = {
        "avg_mood": avg_s("survey_0"),
        "avg_energy": avg_s("survey_1"),
        "avg_weather": avg_s("survey_3"),
        "avg_workout_minutes": avg_s("workout_minutes")
    }

    # Get Activities (last 14 days) + Last Activity
    last_activity = None
    activities = []
    try:
        url = f"https://intervals.icu/api/v1/athlete/{athlete_id}/activities"
        print(f"DEBUG: Fetching activities from {url}...")
        # ×”×•×¡×¤×ª ×˜×•×•×— ×ª××¨×™×›×™× ×œ×× ×™×¢×ª ×©×’×™××ª 422
        res = requests.get(url, auth=auth, params={'oldest': oldest, 'newest': newest, 'limit': 200}, timeout=15)
        print(f"DEBUG: Activities status: {res.status_code}")
        if res.status_code == 200:
            acts = res.json()
            if acts and isinstance(acts, list):
                activities = acts
                if len(activities) > 0:
                    last_activity = activities[0]
                    print(f"DEBUG: Found last activity: {last_activity.get('name')}")
        else:
            print(f"DEBUG: Activities error response: {res.text}")
    except Exception as e:
        print(f"DEBUG: Activities exception: {e}")

    # Aggregate activities by date for graphing
    if activities:
        try:
            activity_by_date = {}
            for act in activities:
                date_local = (act.get("start_date_local") or act.get("start_date") or "")[:10]
                if not date_local:
                    continue
                moving_time = act.get("moving_time", 0) or 0  # seconds
                distance = act.get("distance", 0) or 0  # meters
                if date_local not in activity_by_date:
                    activity_by_date[date_local] = {"workout_minutes": 0, "workout_distance_km": 0, "workout_count": 0}
                activity_by_date[date_local]["workout_minutes"] += round(moving_time / 60, 1)
                activity_by_date[date_local]["workout_distance_km"] += round(distance / 1000, 2)
                activity_by_date[date_local]["workout_count"] += 1

            if activity_by_date:
                batch = db.batch()
                for date_key, vals in activity_by_date.items():
                    hist_ref = db.collection("users").document(doc_id).collection("wellness_history").document(str(date_key))
                    batch.set(hist_ref, vals, merge=True)
                batch.commit()
                print(f"DEBUG: Saved {len(activity_by_date)} activity summaries to history for {doc_id}")
        except Exception as e:
            print(f"DEBUG: Activity aggregation error: {e}")

    today_str = datetime.date.today().isoformat()
    dismissed = user_doc.get("intervention_dismissed_at") == today_str

    # Gender labels
    g = user_doc.get("gender", "male")
    u_name = user_doc.get("name", "×—×‘×¨")
    
    # Simple gender helper for Hebrew strings
    def t(m, f): return f if g == "female" else m

    return {
        "user_name": u_name,
        "gender": g,
        "emergency_name": user_doc.get("emergency_name"),
        "emergency_phone": user_doc.get("emergency_phone"),
        "intervention_dismissed": dismissed,
        "hrv": wellness.get("hrv_consistent", "N/A"),
        "resting_hr": wellness.get("restingHR", "N/A"),
        "stress": wellness.get("stressScore", "N/A"),
        "body_battery": wellness.get("bodyBattery") or wellness.get("body_battery"),
        "sleep": round(wellness.get("sleepSecs", 0) / 3600, 1) if wellness.get("sleepSecs") else "N/A",
        "last_activity": last_activity,
        "date_found": wellness.get("id", "No recent data found"),
        "history": history_list,
        "survey_context": survey_context
    }

# --- AI LOGIC ---
def get_group_pulse(group_id):
    """Calculates anonymized group averages for today."""
    members = db.collection("users").where("group_id", "==", group_id).get()
    moods = []
    energies = []
    
    today_str = datetime.date.today().isoformat()
    for m in members:
        # Check today's wellness history for each member
        hist = db.collection("users").document(m.id).collection("wellness_history").document(today_id).get()
        if hist.exists:
            d = hist.to_dict()
            if "survey_0" in d: moods.append(d["survey_0"])
            if "survey_1" in d: energies.append(d["survey_1"])
            
    if not moods: return None
    
    avg_mood = sum(moods) / len(moods)
    avg_energy = sum(energies) / len(energies)
    
    weather = "×©×§×˜ â˜€ï¸" if avg_mood > 4 else "××¢×•×¨×¤×œ ğŸŒ«ï¸" if avg_mood > 2.5 else "×¡×•×¢×¨ â›ˆï¸"
    
    return f"ğŸŒŠ *×“×•×¤×§ ×§×‘×•×¦×ª×™ ×™×•××™* âš“\n\n××“×“ ×”×× ×¨×’×™×” ×”×××•×¦×¢ ×©×œ× ×•: {round(avg_energy, 1)}/5\n××–×’ ×”××•×•×™×¨ ×”×¤× ×™××™ ×”××©×•×ª×£: {weather}\n\n×–×” ×–××Ÿ ××¦×•×™×Ÿ ×œ×§×—×ª ×¨×’×¢ ×œ× ×©×™××” ××©×•×ª×¤×ª. ××ª× ×œ× ×œ×‘×“. ğŸ¤"

def notify_admin_if_needed(user_id, data):
    """Notifies group admin if a user shows extreme distress."""
    user_doc = db.collection("users").document(_clean_id(user_id)).get().to_dict() or {}
    group_id = user_doc.get("group_id")
    if not group_id: return
    
    group_doc = db.collection("groups").document(group_id).get().to_dict() or {}
    admin_phone = group_doc.get("admin_phone")
    if not admin_phone: return
    
    # Distress Criteria: Mood = 1 OR HRV drop > 30%
    mood = user_doc.get("pcl5_responses", {}).get("0") # Mood is first question
    hrv = data.get("hrv")
    
    if mood == "1" or (isinstance(hrv, (int, float)) and hrv < 20):
        alert = f"âš“ *×¢×“×›×•×Ÿ ×—×•×¡×Ÿ ×œ×× ×”×œ* âš“\n\n×”××©×ª××© {user_doc.get('name')} ×‘×¡×™×›×•×Ÿ ××• ×”×¦×¤×”.\n××“×“ HRV: {hrv}\n×“×™×•×•×— ××¦×‘ ×¨×•×—: 1/5\n\n×›×“××™ ×œ×™×¦×•×¨ ×§×©×¨ ××™×©×™ ×‘×”×§×“×. âœ¨"
        send_wa(admin_phone, alert)

def get_ai_reply(text, data, mode="chat", audio_bytes=None, is_group_msg=False):
    # Prepare information about last activity
    last_act = data.get('last_activity')
    act_info = "No recent activities found"
    if last_act:
        act_info = f"{last_act.get('name')} ({last_act.get('type')}) on {last_act.get('start_date_local')}. Duration: {round(last_act.get('moving_time',0)/60)} min, Distance: {round(last_act.get('distance',0)/1000, 1)} km"

    # Prepare history for the model
    history_str = ""
    history_data = data.get('history', [])
    for h in history_data:
        history_str += f"- Date {h.get('id')}: HRV {h.get('hrv', 'N/A')}, RHR {h.get('restingHR', 'N/A')}, Sleep {round(h.get('sleepSecs',0)/3600,1) if h.get('sleepSecs') else 'N/A'}h\n"

    # 3F Nervous System Logic
    workout_protocol = """
    ## Nervous System States & Interventions (Polyvagal Theory):
    1. Fight/Flight (Hyperarousal, anxiety, high stress, high RHR): 
       - Intervention: Aerobic workouts (regulated), 4-7-8 Breathing, or 5-4-3-2-1 Grounding.
    
    2. Freeze (Dissociation, numbness, low HRV, feeling "stuck"):
       - Intervention: Anaerobic/Strength workouts or Power Yoga to restore agency and power.
    
    3. Collapse (Extreme fatigue, shutdown, low energy, low RHR/HRV):
       - Intervention: Seated practice (Pilates or gentle aerobic) to gently wake up the system with compassion.
    """

    # Safety Protocol
    safety_protocol = """
    ## SOS & Safety Protocol:
    - RED FLAGS: Self-harm intent, extreme dissociation, severe emotional overwhelm, clear crisis.
    - ACTION: If a red flag is detected, set "is_emergency" to true in the JSON output.
    - BOUNDARIES: If the user talks about irrelevant topics, gently guide them back to regulation and self-care.
    """

    # Define task based on mode
    is_dismissed = data.get('intervention_dismissed', False)
    
    if mode == "morning_analysis":
        task_desc = "Mode 1: Morning Analysis (09:00 AM). Analyze metrics vs history and provide insight."
    elif mode == "evening_wind_down":
        task_desc = "Mode 2: Evening Wind-down (09:00 PM). Focus on stress levels and wind-down tips."
    elif mode == "voice_chat":
        task_desc = "Mode: Voice Chat. Act like a calm, supportive listener. Reflect, validate, and ask one open question."
    else:
        task_desc = "Standard Chat Mode. Provide warm, insightful analysis."

    if is_group_msg:
        prompt = f"""
        Role: ×× ×—×” ×§×‘×•×¦×ª×™ ×—×›× ×•×¨×’×™×© ×‘×ª×•×š ×§×‘×•×¦×ª ×•×•××˜×¡××¤ ×©×œ ×¤×•×¡×˜-×˜×¨××•××” (Deep-Rest Guard).
        Task: Analyze the group message: "{text}"
        Instructions:
        1. If the message is intense, triggering, or shows extreme distress, intervene gently.
        2. Remind the group to breathe or take a moment of silence if needed.
        3. Keep the space safe and supportive.
        4. NEVER name specific users or their personal medical data in the group.
        5. Hebrew only, empathetic and calm tone. 
        JSON Output Format: {{ "reply": "YOUR_MESSAGE_HERE", "is_emergency": false }}
        """
    else:
        prompt = f"""
        Role: ××¡×™×¡×˜× ×˜ ×—×›×, ×× ×•×©×™ ×•×¨×’×™×© ×‘×©× Deep-Rest Guard ×”××‘×•×¡×¡ ×¢×œ ×ª×™××•×¨×™×™×ª ×”×¤×•×œ×™×•×•×’×œ.
        User Gender: {data.get('gender')} (IMPORTANT: If female, use feminine Hebrew. If male, use masculine Hebrew).
        
        DATA FOR ANALYSIS (Only if relevant):
        - Today: HRV {data.get('hrv', 'N/A')}, RHR {data.get('resting_hr', 'N/A')}, Sleep {data.get('sleep', 'N/A')}h.
        - Survey Trends (Mood/Energy 1-5): {data.get('survey_context')}
        - History: {history_str}
        - Workout Context: {data.get('active_workout_name', 'None')}
        
        Instructions:
        1. EMPATHY FIRST: Every response to free text MUST start with a warm, empathetic statement reflecting the user's emotional state.
        2. STATE IDENTIFICATION: Identify the user's current nervous system state (Fight/Flight, Freeze, Collapse, or Balanced) based on their words and data.
        3. WORKOUT FOLLOW-UP: If there is an 'active_workout_name' provided, and the user's message is related to it (or just general feedback like 'finished'), ask how it felt and if they need adjustment. If the user's message is about something ELSE (like "help" or "anxious"), focus on that instead but acknowledge the workout if appropriate.
        4. ACTION SUGGESTION: Based on the state, suggest the BEST intervention from the workout protocol. If mode is voice chat, keep it gentle and optional.
        5. SOS DETECTION: Check for red flags (self-harm, total crisis). If found, set "is_emergency": true.
        6. TONE: Warm, human, 3-5 sentences. Use emojis (ğŸ¤, âœ¨, âš“).
        7. PRIVACY: Mention that this stays private: "××” ×©× ×××¨ ×›××Ÿ × ×©××¨ ×‘×™× ×™× ×•".
        
        Context: {task_desc}
        {workout_protocol}
        {safety_protocol}
        
        User Message: "{text if text else '[Voice Note]'}"
        
        JSON Output Format: 
        {{ 
          "reply": "EMPATHETIC_REPLY_TEXT", 
          "is_emergency": true/false, 
          "suggested_action": "workout"/"breath"/"ground"/"none",
          "nervous_system_state": "fight_flight"/"freeze"/"collapse"/"balanced",
          "clear_workout_active": true/false
        }}
        """
    
    contents = []
    if audio_bytes:
        contents.append(types.Part.from_bytes(data=audio_bytes, mime_type="audio/ogg"))
    
    contents.append(prompt)

    try:
        res = gemini_generate(contents)
        ai_data = json.loads(res.text)
        return ai_data
    except Exception as e:
        print(f"AI ERROR (Initial): {e}")
        # Try without JSON mode if it failed due to version mismatch
        try:
            res = gemini_generate(contents)
            res_text = res.text or ""
            if "```json" in res_text:
                res_text = res_text.split("```json")[1].split("```")[0].strip()
            # Clean any remaining non-JSON chars
            if "{" in res_text and "}" in res_text:
                res_text = res_text[res_text.find("{"):res_text.rfind("}")+1]
            return json.loads(res_text)
        except Exception as e2:
            print(f"AI ERROR (Fallback): {e2}")
            err_text = str(e2)
            if "API key was reported as leaked" in err_text or "PERMISSION_DENIED" in err_text:
                return {
                    "reply": "×™×© ×ª×§×œ×” ×–×× ×™×ª ×‘×× ×•×¢ ×”-AI (××¤×ª×— ×”-API × ×—×¡×). ×‘×¨×’×¢ ×©×–×” ×™×•×—×œ×£ ××—×–×•×¨ ×œ×¢× ×•×ª ×›×¨×’×™×œ. ğŸ¤",
                    "is_emergency": False,
                    "suggested_action": "none"
                }
            return {
                "reply": "×”×™×™, ×× ×™ ××¢×‘×“ ××ª ×”× ×ª×•× ×™×, ××™×“ ××¢× ×”. âœ¨",
                "is_emergency": False,
                "suggested_action": "none"
            }

# --- MAIN HANDLER ---
@functions_framework.http
def trigger_sos(sender, user_doc):
    """Activates Emergency Mode and notifies the emergency contact."""
    u_name = user_doc.get("name", "×—×‘×¨")
    e_name = user_doc.get("emergency_name")
    e_phone = user_doc.get("emergency_phone")
    if e_phone:
        # 1. Activate Emergency Mode for 15 minutes
        doc_id = _clean_id(sender)
        expiry = (datetime.datetime.now() + datetime.timedelta(minutes=15)).isoformat()
        db.collection("users").document(doc_id).set({"emergency_mode_expiry": expiry}, merge=True)
        
        # 2. Send Alert
        sender_clean = sender.replace("+", "")
        alert_msg = f"âš“ ×”×•×“×¢×” ×—×©×•×‘×” ×-Deep-Rest Guard: ×”××¢×¨×›×ª ×–×™×”×ª×” ××¦×•×§×” ××©××¢×•×ª×™×ª ××¦×œ {u_name}. ×›×“××™ ×œ×™×¦×•×¨ ×§×©×¨ ×‘×”×§×“×. ğŸ¤\n\n×œ×™×¦×™×¨×ª ×§×©×¨ ××”×™×¨:\nhttps://wa.me/{sender_clean}"
        send_wa(e_phone, alert_msg)
        
        sos_confirmation = f"×”×™×™ {u_name}, ×–×™×”×™×ª×™ ×©××ª/×” ×¢×•×‘×¨/×ª ×¨×’×¢ ×œ× ×¤×©×•×˜. ×”×¤×¢×œ×ª×™ ××ª ×¤×¨×•×˜×•×§×•×œ ×”×¡×™×•×¢ ×•×©×œ×—×ª×™ ×”×•×“×¢×” ×œ{e_name}. âœ¨\n\n×‘-15 ×”×“×§×•×ª ×”×§×¨×•×‘×•×ª, ×›×œ ×ª××•× ×”, ××™×§×•× ××• ×”×§×œ×˜×” ×©×ª×©×œ×—/×™ ×œ×™ ×›××Ÿ ×™×•×¢×‘×¨×• ××œ×™×•/××œ×™×” ××™×“ ×›×“×™ ×©×™×•×›×œ×• ×œ×¢×–×•×¨. ğŸŒ¿ğŸ–¼ï¸ğŸ¤"
        send_wa(sender, sos_confirmation)
        return True
    return False

def handle_ai_response(sender, ai_data, user_doc, intervals_data=None, user_sent_voice=False):
    """Processes the structured AI response and takes actions."""
    reply_text = ai_data.get("reply", "")
    is_emergency = ai_data.get("is_emergency", False)
    suggested_action = ai_data.get("suggested_action", "none")
    state_key = ai_data.get("nervous_system_state", "balanced")
    should_clear_workout = ai_data.get("clear_workout_active", False)

    if should_clear_workout:
        clear_workout_active(sender)

    if is_emergency:
        trigger_sos(sender, user_doc)
        # Even if emergency, we might want to send the empathetic reply too
        if reply_text:
            send_wa(sender, reply_text)
            if user_sent_voice:
                send_tts_reply(sender, reply_text, file_prefix="sos_reply")
        return

    if not reply_text:
        reply_text = f"×”×™×™ {user_doc.get('name', '×—×‘×¨')}, ×× ×™ ×›××Ÿ ××™×ª×š. âœ¨"

    # Send the empathetic reply with the interactive menu
    if is_group(sender):
        send_wa(sender, reply_text)
    else:
        e_name = user_doc.get("emergency_name")
        send_wa(sender, reply_text, interactive_list=get_emergency_list(body_text=reply_text, emergency_name=e_name))
        
    # If the user sent a voice note, we respond with a voice note too
    if user_sent_voice:
        send_tts_reply(sender, reply_text, file_prefix="ai_voice_reply")

    # Trigger suggested actions if any
    if suggested_action == "workout":
        handle_workout_request(sender, user_doc, audio_bytes=None)
    elif suggested_action == "breath":
        maybe_send_regulation_audio(sender, "× ×©×™××”")
    elif suggested_action == "ground":
        maybe_send_regulation_audio(sender, "×§×¨×§×•×¢")

